{"ast":null,"code":"class SearchCacheService {\n  constructor() {\n    this.cacheKey = 'vhealth_search_cache';\n    this.maxCacheSize = 50;\n    // Maximum number of cached searches\n    this.cacheExpiry = 30 * 60 * 1000;\n  }\n  // 30 minutes in milliseconds\n\n  // Get cached result for a query\n  getCachedResult(query) {\n    try {\n      const cache = this.getCache();\n      const normalizedQuery = query.toLowerCase().trim();\n      const cached = cache.find(item => item.query.toLowerCase().trim() === normalizedQuery && Date.now() - item.timestamp < this.cacheExpiry);\n      return cached ? cached.results : null;\n    } catch (error) {\n      console.error('Error retrieving cached result:', error);\n      return null;\n    }\n  }\n\n  // Cache a search result\n  setCachedResult(query, results, url) {\n    try {\n      const cache = this.getCache();\n      const normalizedQuery = query.toLowerCase().trim();\n\n      // Remove existing entry for this query\n      const filteredCache = cache.filter(item => item.query.toLowerCase().trim() !== normalizedQuery);\n\n      // Add new entry at the beginning\n      const newEntry = {\n        query: normalizedQuery,\n        results,\n        timestamp: Date.now(),\n        url\n      };\n      filteredCache.unshift(newEntry);\n\n      // Keep only the most recent entries\n      if (filteredCache.length > this.maxCacheSize) {\n        filteredCache.splice(this.maxCacheSize);\n      }\n      this.saveCache(filteredCache);\n    } catch (error) {\n      console.error('Error caching result:', error);\n    }\n  }\n\n  // Get cached result by URL (for browser navigation)\n  getCachedResultByUrl(url) {\n    try {\n      const cache = this.getCache();\n      const cached = cache.find(item => item.url === url);\n      if (cached && Date.now() - cached.timestamp < this.cacheExpiry) {\n        return {\n          query: cached.query,\n          results: cached.results\n        };\n      }\n      return null;\n    } catch (error) {\n      console.error('Error retrieving cached result by URL:', error);\n      return null;\n    }\n  }\n\n  // Clear expired cache entries\n  clearExpiredCache() {\n    try {\n      const cache = this.getCache();\n      const validCache = cache.filter(item => Date.now() - item.timestamp < this.cacheExpiry);\n      if (validCache.length !== cache.length) {\n        this.saveCache(validCache);\n      }\n    } catch (error) {\n      console.error('Error clearing expired cache:', error);\n    }\n  }\n\n  // Clear all cache\n  clearAllCache() {\n    try {\n      sessionStorage.removeItem(this.cacheKey);\n    } catch (error) {\n      console.error('Error clearing cache:', error);\n    }\n  }\n\n  // Get all cached results\n  getCache() {\n    try {\n      const cached = sessionStorage.getItem(this.cacheKey);\n      return cached ? JSON.parse(cached) : [];\n    } catch (error) {\n      console.error('Error parsing cache:', error);\n      return [];\n    }\n  }\n\n  // Save cache to sessionStorage\n  saveCache(cache) {\n    try {\n      sessionStorage.setItem(this.cacheKey, JSON.stringify(cache));\n    } catch (error) {\n      console.error('Error saving cache:', error);\n    }\n  }\n\n  // Get cache statistics\n  getCacheStats() {\n    const cache = this.getCache();\n    const oldestTimestamp = cache.length > 0 ? Math.min(...cache.map(item => item.timestamp)) : null;\n    return {\n      size: cache.length,\n      oldestEntry: oldestTimestamp ? new Date(oldestTimestamp) : null\n    };\n  }\n}\nexport const searchCache = new SearchCacheService();","map":{"version":3,"names":["SearchCacheService","constructor","cacheKey","maxCacheSize","cacheExpiry","getCachedResult","query","cache","getCache","normalizedQuery","toLowerCase","trim","cached","find","item","Date","now","timestamp","results","error","console","setCachedResult","url","filteredCache","filter","newEntry","unshift","length","splice","saveCache","getCachedResultByUrl","clearExpiredCache","validCache","clearAllCache","sessionStorage","removeItem","getItem","JSON","parse","setItem","stringify","getCacheStats","oldestTimestamp","Math","min","map","size","oldestEntry","searchCache"],"sources":["C:/repo/wihy_ui/client/src/services/searchCache.ts"],"sourcesContent":["interface CachedResult {\r\n  query: string;\r\n  results: string;\r\n  timestamp: number;\r\n  url: string;\r\n}\r\n\r\nclass SearchCacheService {\r\n  private cacheKey = 'vhealth_search_cache';\r\n  private maxCacheSize = 50; // Maximum number of cached searches\r\n  private cacheExpiry = 30 * 60 * 1000; // 30 minutes in milliseconds\r\n\r\n  // Get cached result for a query\r\n  getCachedResult(query: string): string | null {\r\n    try {\r\n      const cache = this.getCache();\r\n      const normalizedQuery = query.toLowerCase().trim();\r\n      \r\n      const cached = cache.find(item => \r\n        item.query.toLowerCase().trim() === normalizedQuery &&\r\n        (Date.now() - item.timestamp) < this.cacheExpiry\r\n      );\r\n\r\n      return cached ? cached.results : null;\r\n    } catch (error) {\r\n      console.error('Error retrieving cached result:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  // Cache a search result\r\n  setCachedResult(query: string, results: string, url: string): void {\r\n    try {\r\n      const cache = this.getCache();\r\n      const normalizedQuery = query.toLowerCase().trim();\r\n      \r\n      // Remove existing entry for this query\r\n      const filteredCache = cache.filter(item => \r\n        item.query.toLowerCase().trim() !== normalizedQuery\r\n      );\r\n\r\n      // Add new entry at the beginning\r\n      const newEntry: CachedResult = {\r\n        query: normalizedQuery,\r\n        results,\r\n        timestamp: Date.now(),\r\n        url\r\n      };\r\n\r\n      filteredCache.unshift(newEntry);\r\n\r\n      // Keep only the most recent entries\r\n      if (filteredCache.length > this.maxCacheSize) {\r\n        filteredCache.splice(this.maxCacheSize);\r\n      }\r\n\r\n      this.saveCache(filteredCache);\r\n    } catch (error) {\r\n      console.error('Error caching result:', error);\r\n    }\r\n  }\r\n\r\n  // Get cached result by URL (for browser navigation)\r\n  getCachedResultByUrl(url: string): { query: string; results: string } | null {\r\n    try {\r\n      const cache = this.getCache();\r\n      const cached = cache.find(item => item.url === url);\r\n      \r\n      if (cached && (Date.now() - cached.timestamp) < this.cacheExpiry) {\r\n        return {\r\n          query: cached.query,\r\n          results: cached.results\r\n        };\r\n      }\r\n      \r\n      return null;\r\n    } catch (error) {\r\n      console.error('Error retrieving cached result by URL:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  // Clear expired cache entries\r\n  clearExpiredCache(): void {\r\n    try {\r\n      const cache = this.getCache();\r\n      const validCache = cache.filter(item => \r\n        (Date.now() - item.timestamp) < this.cacheExpiry\r\n      );\r\n      \r\n      if (validCache.length !== cache.length) {\r\n        this.saveCache(validCache);\r\n      }\r\n    } catch (error) {\r\n      console.error('Error clearing expired cache:', error);\r\n    }\r\n  }\r\n\r\n  // Clear all cache\r\n  clearAllCache(): void {\r\n    try {\r\n      sessionStorage.removeItem(this.cacheKey);\r\n    } catch (error) {\r\n      console.error('Error clearing cache:', error);\r\n    }\r\n  }\r\n\r\n  // Get all cached results\r\n  private getCache(): CachedResult[] {\r\n    try {\r\n      const cached = sessionStorage.getItem(this.cacheKey);\r\n      return cached ? JSON.parse(cached) : [];\r\n    } catch (error) {\r\n      console.error('Error parsing cache:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  // Save cache to sessionStorage\r\n  private saveCache(cache: CachedResult[]): void {\r\n    try {\r\n      sessionStorage.setItem(this.cacheKey, JSON.stringify(cache));\r\n    } catch (error) {\r\n      console.error('Error saving cache:', error);\r\n    }\r\n  }\r\n\r\n  // Get cache statistics\r\n  getCacheStats(): { size: number; oldestEntry: Date | null } {\r\n    const cache = this.getCache();\r\n    const oldestTimestamp = cache.length > 0 \r\n      ? Math.min(...cache.map(item => item.timestamp))\r\n      : null;\r\n    \r\n    return {\r\n      size: cache.length,\r\n      oldestEntry: oldestTimestamp ? new Date(oldestTimestamp) : null\r\n    };\r\n  }\r\n}\r\n\r\nexport const searchCache = new SearchCacheService();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}