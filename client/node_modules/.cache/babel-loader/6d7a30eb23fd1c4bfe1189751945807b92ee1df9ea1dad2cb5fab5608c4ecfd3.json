{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\nimport * as base64 from \"./util/base64\";\nimport * as utils from \"./util/utils\";\nvar Serializer = /** @class */function () {\n  function Serializer(modelMappers, isXML) {\n    if (modelMappers === void 0) {\n      modelMappers = {};\n    }\n    this.modelMappers = modelMappers;\n    this.isXML = isXML;\n  }\n  Serializer.prototype.validateConstraints = function (mapper, value, objectName) {\n    var failValidation = function (constraintName, constraintValue) {\n      throw new Error(\"\\\"\" + objectName + \"\\\" with value \\\"\" + value + \"\\\" should satisfy the constraint \\\"\" + constraintName + \"\\\": \" + constraintValue + \".\");\n    };\n    if (mapper.constraints && value != undefined) {\n      var _a = mapper.constraints,\n        ExclusiveMaximum = _a.ExclusiveMaximum,\n        ExclusiveMinimum = _a.ExclusiveMinimum,\n        InclusiveMaximum = _a.InclusiveMaximum,\n        InclusiveMinimum = _a.InclusiveMinimum,\n        MaxItems = _a.MaxItems,\n        MaxLength = _a.MaxLength,\n        MinItems = _a.MinItems,\n        MinLength = _a.MinLength,\n        MultipleOf = _a.MultipleOf,\n        Pattern = _a.Pattern,\n        UniqueItems = _a.UniqueItems;\n      if (ExclusiveMaximum != undefined && value >= ExclusiveMaximum) {\n        failValidation(\"ExclusiveMaximum\", ExclusiveMaximum);\n      }\n      if (ExclusiveMinimum != undefined && value <= ExclusiveMinimum) {\n        failValidation(\"ExclusiveMinimum\", ExclusiveMinimum);\n      }\n      if (InclusiveMaximum != undefined && value > InclusiveMaximum) {\n        failValidation(\"InclusiveMaximum\", InclusiveMaximum);\n      }\n      if (InclusiveMinimum != undefined && value < InclusiveMinimum) {\n        failValidation(\"InclusiveMinimum\", InclusiveMinimum);\n      }\n      if (MaxItems != undefined && value.length > MaxItems) {\n        failValidation(\"MaxItems\", MaxItems);\n      }\n      if (MaxLength != undefined && value.length > MaxLength) {\n        failValidation(\"MaxLength\", MaxLength);\n      }\n      if (MinItems != undefined && value.length < MinItems) {\n        failValidation(\"MinItems\", MinItems);\n      }\n      if (MinLength != undefined && value.length < MinLength) {\n        failValidation(\"MinLength\", MinLength);\n      }\n      if (MultipleOf != undefined && value % MultipleOf !== 0) {\n        failValidation(\"MultipleOf\", MultipleOf);\n      }\n      if (Pattern) {\n        var pattern = typeof Pattern === \"string\" ? new RegExp(Pattern) : Pattern;\n        if (typeof value !== \"string\" || value.match(pattern) === null) {\n          failValidation(\"Pattern\", Pattern);\n        }\n      }\n      if (UniqueItems && value.some(function (item, i, ar) {\n        return ar.indexOf(item) !== i;\n      })) {\n        failValidation(\"UniqueItems\", UniqueItems);\n      }\n    }\n  };\n  /**\n   * Serialize the given object based on its metadata defined in the mapper\n   *\n   * @param {Mapper} mapper The mapper which defines the metadata of the serializable object\n   *\n   * @param {object|string|Array|number|boolean|Date|stream} object A valid Javascript object to be serialized\n   *\n   * @param {string} objectName Name of the serialized object\n   *\n   * @returns {object|string|Array|number|boolean|Date|stream} A valid serialized Javascript object\n   */\n  Serializer.prototype.serialize = function (mapper, object, objectName) {\n    var payload = {};\n    var mapperType = mapper.type.name;\n    if (!objectName) {\n      objectName = mapper.serializedName;\n    }\n    if (mapperType.match(/^Sequence$/gi) !== null) {\n      payload = [];\n    }\n    if (mapper.isConstant) {\n      object = mapper.defaultValue;\n    }\n    // This table of allowed values should help explain\n    // the mapper.required and mapper.nullable properties.\n    // X means \"neither undefined or null are allowed\".\n    //           || required\n    //           || true      | false\n    //  nullable || ==========================\n    //      true || null      | undefined/null\n    //     false || X         | undefined\n    // undefined || X         | undefined/null\n    var required = mapper.required,\n      nullable = mapper.nullable;\n    if (required && nullable && object === undefined) {\n      throw new Error(objectName + \" cannot be undefined.\");\n    }\n    if (required && !nullable && object == undefined) {\n      throw new Error(objectName + \" cannot be null or undefined.\");\n    }\n    if (!required && nullable === false && object === null) {\n      throw new Error(objectName + \" cannot be null.\");\n    }\n    if (object == undefined) {\n      payload = object;\n    } else {\n      // Validate Constraints if any\n      this.validateConstraints(mapper, object, objectName);\n      if (mapperType.match(/^any$/gi) !== null) {\n        payload = object;\n      } else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/gi) !== null) {\n        payload = serializeBasicTypes(mapperType, objectName, object);\n      } else if (mapperType.match(/^Enum$/gi) !== null) {\n        var enumMapper = mapper;\n        payload = serializeEnumType(objectName, enumMapper.type.allowedValues, object);\n      } else if (mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/gi) !== null) {\n        payload = serializeDateTypes(mapperType, object, objectName);\n      } else if (mapperType.match(/^ByteArray$/gi) !== null) {\n        payload = serializeByteArrayType(objectName, object);\n      } else if (mapperType.match(/^Base64Url$/gi) !== null) {\n        payload = serializeBase64UrlType(objectName, object);\n      } else if (mapperType.match(/^Sequence$/gi) !== null) {\n        payload = serializeSequenceType(this, mapper, object, objectName);\n      } else if (mapperType.match(/^Dictionary$/gi) !== null) {\n        payload = serializeDictionaryType(this, mapper, object, objectName);\n      } else if (mapperType.match(/^Composite$/gi) !== null) {\n        payload = serializeCompositeType(this, mapper, object, objectName);\n      }\n    }\n    return payload;\n  };\n  /**\n   * Deserialize the given object based on its metadata defined in the mapper\n   *\n   * @param {object} mapper The mapper which defines the metadata of the serializable object\n   *\n   * @param {object|string|Array|number|boolean|Date|stream} responseBody A valid Javascript entity to be deserialized\n   *\n   * @param {string} objectName Name of the deserialized object\n   *\n   * @returns {object|string|Array|number|boolean|Date|stream} A valid deserialized Javascript object\n   */\n  Serializer.prototype.deserialize = function (mapper, responseBody, objectName) {\n    if (responseBody == undefined) {\n      if (this.isXML && mapper.type.name === \"Sequence\" && !mapper.xmlIsWrapped) {\n        // Edge case for empty XML non-wrapped lists. xml2js can't distinguish\n        // between the list being empty versus being missing,\n        // so let's do the more user-friendly thing and return an empty list.\n        responseBody = [];\n      }\n      // specifically check for undefined as default value can be a falsey value `0, \"\", false, null`\n      if (mapper.defaultValue !== undefined) {\n        responseBody = mapper.defaultValue;\n      }\n      return responseBody;\n    }\n    var payload;\n    var mapperType = mapper.type.name;\n    if (!objectName) {\n      objectName = mapper.serializedName;\n    }\n    if (mapperType.match(/^Composite$/gi) !== null) {\n      payload = deserializeCompositeType(this, mapper, responseBody, objectName);\n    } else {\n      if (this.isXML) {\n        /**\n         * If the mapper specifies this as a non-composite type value but the responseBody contains\n         * both header (\"$\") and body (\"_\") properties, then just reduce the responseBody value to\n         * the body (\"_\") property.\n         */\n        if (responseBody[\"$\"] != undefined && responseBody[\"_\"] != undefined) {\n          responseBody = responseBody[\"_\"];\n        }\n      }\n      if (mapperType.match(/^Number$/gi) !== null) {\n        payload = parseFloat(responseBody);\n        if (isNaN(payload)) {\n          payload = responseBody;\n        }\n      } else if (mapperType.match(/^Boolean$/gi) !== null) {\n        if (responseBody === \"true\") {\n          payload = true;\n        } else if (responseBody === \"false\") {\n          payload = false;\n        } else {\n          payload = responseBody;\n        }\n      } else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/gi) !== null) {\n        payload = responseBody;\n      } else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/gi) !== null) {\n        payload = new Date(responseBody);\n      } else if (mapperType.match(/^UnixTime$/gi) !== null) {\n        payload = unixTimeToDate(responseBody);\n      } else if (mapperType.match(/^ByteArray$/gi) !== null) {\n        payload = base64.decodeString(responseBody);\n      } else if (mapperType.match(/^Base64Url$/gi) !== null) {\n        payload = base64UrlToByteArray(responseBody);\n      } else if (mapperType.match(/^Sequence$/gi) !== null) {\n        payload = deserializeSequenceType(this, mapper, responseBody, objectName);\n      } else if (mapperType.match(/^Dictionary$/gi) !== null) {\n        payload = deserializeDictionaryType(this, mapper, responseBody, objectName);\n      }\n    }\n    if (mapper.isConstant) {\n      payload = mapper.defaultValue;\n    }\n    return payload;\n  };\n  return Serializer;\n}();\nexport { Serializer };\nfunction trimEnd(str, ch) {\n  var len = str.length;\n  while (len - 1 >= 0 && str[len - 1] === ch) {\n    --len;\n  }\n  return str.substr(0, len);\n}\nfunction bufferToBase64Url(buffer) {\n  if (!buffer) {\n    return undefined;\n  }\n  if (!(buffer instanceof Uint8Array)) {\n    throw new Error(\"Please provide an input of type Uint8Array for converting to Base64Url.\");\n  }\n  // Uint8Array to Base64.\n  var str = base64.encodeByteArray(buffer);\n  // Base64 to Base64Url.\n  return trimEnd(str, \"=\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\nfunction base64UrlToByteArray(str) {\n  if (!str) {\n    return undefined;\n  }\n  if (str && typeof str.valueOf() !== \"string\") {\n    throw new Error(\"Please provide an input of type string for converting to Uint8Array\");\n  }\n  // Base64Url to Base64.\n  str = str.replace(/\\-/g, \"+\").replace(/\\_/g, \"/\");\n  // Base64 to Uint8Array.\n  return base64.decodeString(str);\n}\nfunction splitSerializeName(prop) {\n  var classes = [];\n  var partialclass = \"\";\n  if (prop) {\n    var subwords = prop.split(\".\");\n    for (var _i = 0, subwords_1 = subwords; _i < subwords_1.length; _i++) {\n      var item = subwords_1[_i];\n      if (item.charAt(item.length - 1) === \"\\\\\") {\n        partialclass += item.substr(0, item.length - 1) + \".\";\n      } else {\n        partialclass += item;\n        classes.push(partialclass);\n        partialclass = \"\";\n      }\n    }\n  }\n  return classes;\n}\nfunction dateToUnixTime(d) {\n  if (!d) {\n    return undefined;\n  }\n  if (typeof d.valueOf() === \"string\") {\n    d = new Date(d);\n  }\n  return Math.floor(d.getTime() / 1000);\n}\nfunction unixTimeToDate(n) {\n  if (!n) {\n    return undefined;\n  }\n  return new Date(n * 1000);\n}\nfunction serializeBasicTypes(typeName, objectName, value) {\n  if (value !== null && value !== undefined) {\n    if (typeName.match(/^Number$/gi) !== null) {\n      if (typeof value !== \"number\") {\n        throw new Error(objectName + \" with value \" + value + \" must be of type number.\");\n      }\n    } else if (typeName.match(/^String$/gi) !== null) {\n      if (typeof value.valueOf() !== \"string\") {\n        throw new Error(objectName + \" with value \\\"\" + value + \"\\\" must be of type string.\");\n      }\n    } else if (typeName.match(/^Uuid$/gi) !== null) {\n      if (!(typeof value.valueOf() === \"string\" && utils.isValidUuid(value))) {\n        throw new Error(objectName + \" with value \\\"\" + value + \"\\\" must be of type string and a valid uuid.\");\n      }\n    } else if (typeName.match(/^Boolean$/gi) !== null) {\n      if (typeof value !== \"boolean\") {\n        throw new Error(objectName + \" with value \" + value + \" must be of type boolean.\");\n      }\n    } else if (typeName.match(/^Stream$/gi) !== null) {\n      var objectType = typeof value;\n      if (objectType !== \"string\" && objectType !== \"function\" && !(value instanceof ArrayBuffer) && !ArrayBuffer.isView(value) && !(typeof Blob === \"function\" && value instanceof Blob)) {\n        throw new Error(objectName + \" must be a string, Blob, ArrayBuffer, ArrayBufferView, or a function returning NodeJS.ReadableStream.\");\n      }\n    }\n  }\n  return value;\n}\nfunction serializeEnumType(objectName, allowedValues, value) {\n  if (!allowedValues) {\n    throw new Error(\"Please provide a set of allowedValues to validate \" + objectName + \" as an Enum Type.\");\n  }\n  var isPresent = allowedValues.some(function (item) {\n    if (typeof item.valueOf() === \"string\") {\n      return item.toLowerCase() === value.toLowerCase();\n    }\n    return item === value;\n  });\n  if (!isPresent) {\n    throw new Error(value + \" is not a valid value for \" + objectName + \". The valid values are: \" + JSON.stringify(allowedValues) + \".\");\n  }\n  return value;\n}\nfunction serializeByteArrayType(objectName, value) {\n  if (value != undefined) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error(objectName + \" must be of type Uint8Array.\");\n    }\n    value = base64.encodeByteArray(value);\n  }\n  return value;\n}\nfunction serializeBase64UrlType(objectName, value) {\n  if (value != undefined) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error(objectName + \" must be of type Uint8Array.\");\n    }\n    value = bufferToBase64Url(value);\n  }\n  return value;\n}\nfunction serializeDateTypes(typeName, value, objectName) {\n  if (value != undefined) {\n    if (typeName.match(/^Date$/gi) !== null) {\n      if (!(value instanceof Date || typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))) {\n        throw new Error(objectName + \" must be an instanceof Date or a string in ISO8601 format.\");\n      }\n      value = value instanceof Date ? value.toISOString().substring(0, 10) : new Date(value).toISOString().substring(0, 10);\n    } else if (typeName.match(/^DateTime$/gi) !== null) {\n      if (!(value instanceof Date || typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))) {\n        throw new Error(objectName + \" must be an instanceof Date or a string in ISO8601 format.\");\n      }\n      value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();\n    } else if (typeName.match(/^DateTimeRfc1123$/gi) !== null) {\n      if (!(value instanceof Date || typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))) {\n        throw new Error(objectName + \" must be an instanceof Date or a string in RFC-1123 format.\");\n      }\n      value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();\n    } else if (typeName.match(/^UnixTime$/gi) !== null) {\n      if (!(value instanceof Date || typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))) {\n        throw new Error(objectName + \" must be an instanceof Date or a string in RFC-1123/ISO8601 format \" + \"for it to be serialized in UnixTime/Epoch format.\");\n      }\n      value = dateToUnixTime(value);\n    } else if (typeName.match(/^TimeSpan$/gi) !== null) {\n      if (!utils.isDuration(value)) {\n        throw new Error(objectName + \" must be a string in ISO 8601 format. Instead was \\\"\" + value + \"\\\".\");\n      }\n      value = value;\n    }\n  }\n  return value;\n}\nfunction serializeSequenceType(serializer, mapper, object, objectName) {\n  if (!Array.isArray(object)) {\n    throw new Error(objectName + \" must be of type Array.\");\n  }\n  var elementType = mapper.type.element;\n  if (!elementType || typeof elementType !== \"object\") {\n    throw new Error(\"element\\\" metadata for an Array must be defined in the \" + (\"mapper and it must of type \\\"object\\\" in \" + objectName + \".\"));\n  }\n  var tempArray = [];\n  for (var i = 0; i < object.length; i++) {\n    tempArray[i] = serializer.serialize(elementType, object[i], objectName);\n  }\n  return tempArray;\n}\nfunction serializeDictionaryType(serializer, mapper, object, objectName) {\n  if (typeof object !== \"object\") {\n    throw new Error(objectName + \" must be of type object.\");\n  }\n  var valueType = mapper.type.value;\n  if (!valueType || typeof valueType !== \"object\") {\n    throw new Error(\"\\\"value\\\" metadata for a Dictionary must be defined in the \" + (\"mapper and it must of type \\\"object\\\" in \" + objectName + \".\"));\n  }\n  var tempDictionary = {};\n  for (var _i = 0, _a = Object.keys(object); _i < _a.length; _i++) {\n    var key = _a[_i];\n    tempDictionary[key] = serializer.serialize(valueType, object[key], objectName + \".\" + key);\n  }\n  return tempDictionary;\n}\n/**\n * Resolves a composite mapper's modelProperties.\n * @param serializer the serializer containing the entire set of mappers\n * @param mapper the composite mapper to resolve\n */\nfunction resolveModelProperties(serializer, mapper, objectName) {\n  var modelProps = mapper.type.modelProperties;\n  if (!modelProps) {\n    var className = mapper.type.className;\n    if (!className) {\n      throw new Error(\"Class name for model \\\"\" + objectName + \"\\\" is not provided in the mapper \\\"\" + JSON.stringify(mapper, undefined, 2) + \"\\\".\");\n    }\n    var modelMapper = serializer.modelMappers[className];\n    if (!modelMapper) {\n      throw new Error(\"mapper() cannot be null or undefined for model \\\"\" + className + \"\\\".\");\n    }\n    modelProps = modelMapper.type.modelProperties;\n    if (!modelProps) {\n      throw new Error(\"modelProperties cannot be null or undefined in the \" + (\"mapper \\\"\" + JSON.stringify(modelMapper) + \"\\\" of type \\\"\" + className + \"\\\" for object \\\"\" + objectName + \"\\\".\"));\n    }\n  }\n  return modelProps;\n}\nfunction serializeCompositeType(serializer, mapper, object, objectName) {\n  var _a;\n  if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {\n    mapper = getPolymorphicMapper(serializer, mapper, object, \"clientName\");\n  }\n  if (object != undefined) {\n    var payload = {};\n    var modelProps = resolveModelProperties(serializer, mapper, objectName);\n    for (var _i = 0, _b = Object.keys(modelProps); _i < _b.length; _i++) {\n      var key = _b[_i];\n      var propertyMapper = modelProps[key];\n      if (propertyMapper.readOnly) {\n        continue;\n      }\n      var propName = void 0;\n      var parentObject = payload;\n      if (serializer.isXML) {\n        if (propertyMapper.xmlIsWrapped) {\n          propName = propertyMapper.xmlName;\n        } else {\n          propName = propertyMapper.xmlElementName || propertyMapper.xmlName;\n        }\n      } else {\n        var paths = splitSerializeName(propertyMapper.serializedName);\n        propName = paths.pop();\n        for (var _c = 0, paths_1 = paths; _c < paths_1.length; _c++) {\n          var pathName = paths_1[_c];\n          var childObject = parentObject[pathName];\n          if (childObject == undefined && object[key] != undefined) {\n            parentObject[pathName] = {};\n          }\n          parentObject = parentObject[pathName];\n        }\n      }\n      if (parentObject != undefined) {\n        var propertyObjectName = propertyMapper.serializedName !== \"\" ? objectName + \".\" + propertyMapper.serializedName : objectName;\n        var toSerialize = object[key];\n        var polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);\n        if (polymorphicDiscriminator && polymorphicDiscriminator.clientName === key && toSerialize == undefined) {\n          toSerialize = mapper.serializedName;\n        }\n        var serializedValue = serializer.serialize(propertyMapper, toSerialize, propertyObjectName);\n        if (serializedValue !== undefined && propName != undefined) {\n          if (propertyMapper.xmlIsAttribute) {\n            // $ is the key attributes are kept under in xml2js.\n            // This keeps things simple while preventing name collision\n            // with names in user documents.\n            parentObject.$ = parentObject.$ || {};\n            parentObject.$[propName] = serializedValue;\n          } else if (propertyMapper.xmlIsWrapped) {\n            parentObject[propName] = (_a = {}, _a[propertyMapper.xmlElementName] = serializedValue, _a);\n          } else {\n            parentObject[propName] = serializedValue;\n          }\n        }\n      }\n    }\n    var additionalPropertiesMapper = mapper.type.additionalProperties;\n    if (additionalPropertiesMapper) {\n      var propNames = Object.keys(modelProps);\n      var _loop_1 = function (clientPropName) {\n        var isAdditionalProperty = propNames.every(function (pn) {\n          return pn !== clientPropName;\n        });\n        if (isAdditionalProperty) {\n          payload[clientPropName] = serializer.serialize(additionalPropertiesMapper, object[clientPropName], objectName + '[\"' + clientPropName + '\"]');\n        }\n      };\n      for (var clientPropName in object) {\n        _loop_1(clientPropName);\n      }\n    }\n    return payload;\n  }\n  return object;\n}\nfunction isSpecialXmlProperty(propertyName) {\n  return [\"$\", \"_\"].includes(propertyName);\n}\nfunction deserializeCompositeType(serializer, mapper, responseBody, objectName) {\n  if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {\n    mapper = getPolymorphicMapper(serializer, mapper, responseBody, \"serializedName\");\n  }\n  var modelProps = resolveModelProperties(serializer, mapper, objectName);\n  var instance = {};\n  var handledPropertyNames = [];\n  for (var _i = 0, _a = Object.keys(modelProps); _i < _a.length; _i++) {\n    var key = _a[_i];\n    var propertyMapper = modelProps[key];\n    var paths = splitSerializeName(modelProps[key].serializedName);\n    handledPropertyNames.push(paths[0]);\n    var serializedName = propertyMapper.serializedName,\n      xmlName = propertyMapper.xmlName,\n      xmlElementName = propertyMapper.xmlElementName;\n    var propertyObjectName = objectName;\n    if (serializedName !== \"\" && serializedName !== undefined) {\n      propertyObjectName = objectName + \".\" + serializedName;\n    }\n    var headerCollectionPrefix = propertyMapper.headerCollectionPrefix;\n    if (headerCollectionPrefix) {\n      var dictionary = {};\n      for (var _b = 0, _c = Object.keys(responseBody); _b < _c.length; _b++) {\n        var headerKey = _c[_b];\n        if (headerKey.startsWith(headerCollectionPrefix)) {\n          dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer.deserialize(propertyMapper.type.value, responseBody[headerKey], propertyObjectName);\n        }\n        handledPropertyNames.push(headerKey);\n      }\n      instance[key] = dictionary;\n    } else if (serializer.isXML) {\n      if (propertyMapper.xmlIsAttribute && responseBody.$) {\n        instance[key] = serializer.deserialize(propertyMapper, responseBody.$[xmlName], propertyObjectName);\n      } else {\n        var propertyName = xmlElementName || xmlName || serializedName;\n        var unwrappedProperty = responseBody[propertyName];\n        if (propertyMapper.xmlIsWrapped) {\n          unwrappedProperty = responseBody[xmlName];\n          unwrappedProperty = unwrappedProperty && unwrappedProperty[xmlElementName];\n          var isEmptyWrappedList = unwrappedProperty === undefined;\n          if (isEmptyWrappedList) {\n            unwrappedProperty = [];\n          }\n        }\n        instance[key] = serializer.deserialize(propertyMapper, unwrappedProperty, propertyObjectName);\n      }\n    } else {\n      // deserialize the property if it is present in the provided responseBody instance\n      var propertyInstance = void 0;\n      var res = responseBody;\n      // traversing the object step by step.\n      for (var _d = 0, paths_2 = paths; _d < paths_2.length; _d++) {\n        var item = paths_2[_d];\n        if (!res) break;\n        res = res[item];\n      }\n      propertyInstance = res;\n      var polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;\n      // checking that the model property name (key)(ex: \"fishtype\") and the\n      // clientName of the polymorphicDiscriminator {metadata} (ex: \"fishtype\")\n      // instead of the serializedName of the polymorphicDiscriminator (ex: \"fish.type\")\n      // is a better approach. The generator is not consistent with escaping '\\.' in the\n      // serializedName of the property (ex: \"fish\\.type\") that is marked as polymorphic discriminator\n      // and the serializedName of the metadata polymorphicDiscriminator (ex: \"fish.type\"). However,\n      // the clientName transformation of the polymorphicDiscriminator (ex: \"fishtype\") and\n      // the transformation of model property name (ex: \"fishtype\") is done consistently.\n      // Hence, it is a safer bet to rely on the clientName of the polymorphicDiscriminator.\n      if (polymorphicDiscriminator && key === polymorphicDiscriminator.clientName && propertyInstance == undefined) {\n        propertyInstance = mapper.serializedName;\n      }\n      var serializedValue = void 0;\n      // paging\n      if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === \"\") {\n        propertyInstance = responseBody[key];\n        var arrayInstance = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName);\n        // Copy over any properties that have already been added into the instance, where they do\n        // not exist on the newly de-serialized array\n        for (var _e = 0, _f = Object.entries(instance); _e < _f.length; _e++) {\n          var _g = _f[_e],\n            key_1 = _g[0],\n            value = _g[1];\n          if (!arrayInstance.hasOwnProperty(key_1)) {\n            arrayInstance[key_1] = value;\n          }\n        }\n        instance = arrayInstance;\n      } else if (propertyInstance !== undefined || propertyMapper.defaultValue !== undefined) {\n        serializedValue = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName);\n        instance[key] = serializedValue;\n      }\n    }\n  }\n  var additionalPropertiesMapper = mapper.type.additionalProperties;\n  if (additionalPropertiesMapper) {\n    var isAdditionalProperty = function (responsePropName) {\n      for (var clientPropName in modelProps) {\n        var paths = splitSerializeName(modelProps[clientPropName].serializedName);\n        if (paths[0] === responsePropName) {\n          return false;\n        }\n      }\n      return true;\n    };\n    for (var responsePropName in responseBody) {\n      if (isAdditionalProperty(responsePropName)) {\n        instance[responsePropName] = serializer.deserialize(additionalPropertiesMapper, responseBody[responsePropName], objectName + '[\"' + responsePropName + '\"]');\n      }\n    }\n  } else if (responseBody) {\n    for (var _h = 0, _j = Object.keys(responseBody); _h < _j.length; _h++) {\n      var key = _j[_h];\n      if (instance[key] === undefined && !handledPropertyNames.includes(key) && !isSpecialXmlProperty(key)) {\n        instance[key] = responseBody[key];\n      }\n    }\n  }\n  return instance;\n}\nfunction deserializeDictionaryType(serializer, mapper, responseBody, objectName) {\n  /*jshint validthis: true */\n  var value = mapper.type.value;\n  if (!value || typeof value !== \"object\") {\n    throw new Error(\"\\\"value\\\" metadata for a Dictionary must be defined in the \" + (\"mapper and it must of type \\\"object\\\" in \" + objectName));\n  }\n  if (responseBody) {\n    var tempDictionary = {};\n    for (var _i = 0, _a = Object.keys(responseBody); _i < _a.length; _i++) {\n      var key = _a[_i];\n      tempDictionary[key] = serializer.deserialize(value, responseBody[key], objectName);\n    }\n    return tempDictionary;\n  }\n  return responseBody;\n}\nfunction deserializeSequenceType(serializer, mapper, responseBody, objectName) {\n  /*jshint validthis: true */\n  var element = mapper.type.element;\n  if (!element || typeof element !== \"object\") {\n    throw new Error(\"element\\\" metadata for an Array must be defined in the \" + (\"mapper and it must of type \\\"object\\\" in \" + objectName));\n  }\n  if (responseBody) {\n    if (!Array.isArray(responseBody)) {\n      // xml2js will interpret a single element array as just the element, so force it to be an array\n      responseBody = [responseBody];\n    }\n    var tempArray = [];\n    for (var i = 0; i < responseBody.length; i++) {\n      tempArray[i] = serializer.deserialize(element, responseBody[i], objectName + \"[\" + i + \"]\");\n    }\n    return tempArray;\n  }\n  return responseBody;\n}\nfunction getPolymorphicMapper(serializer, mapper, object, polymorphicPropertyName) {\n  var polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);\n  if (polymorphicDiscriminator) {\n    var discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];\n    if (discriminatorName != undefined) {\n      var discriminatorValue = object[discriminatorName];\n      if (discriminatorValue != undefined) {\n        var typeName = mapper.type.uberParent || mapper.type.className;\n        var indexDiscriminator = discriminatorValue === typeName ? discriminatorValue : typeName + \".\" + discriminatorValue;\n        var polymorphicMapper = serializer.modelMappers.discriminators[indexDiscriminator];\n        if (polymorphicMapper) {\n          mapper = polymorphicMapper;\n        }\n      }\n    }\n  }\n  return mapper;\n}\nfunction getPolymorphicDiscriminatorRecursively(serializer, mapper) {\n  return mapper.type.polymorphicDiscriminator || getPolymorphicDiscriminatorSafely(serializer, mapper.type.uberParent) || getPolymorphicDiscriminatorSafely(serializer, mapper.type.className);\n}\nfunction getPolymorphicDiscriminatorSafely(serializer, typeName) {\n  return typeName && serializer.modelMappers[typeName] && serializer.modelMappers[typeName].type.polymorphicDiscriminator;\n}\n// TODO: why is this here?\nexport function serializeObject(toSerialize) {\n  if (toSerialize == undefined) return undefined;\n  if (toSerialize instanceof Uint8Array) {\n    toSerialize = base64.encodeByteArray(toSerialize);\n    return toSerialize;\n  } else if (toSerialize instanceof Date) {\n    return toSerialize.toISOString();\n  } else if (Array.isArray(toSerialize)) {\n    var array = [];\n    for (var i = 0; i < toSerialize.length; i++) {\n      array.push(serializeObject(toSerialize[i]));\n    }\n    return array;\n  } else if (typeof toSerialize === \"object\") {\n    var dictionary = {};\n    for (var property in toSerialize) {\n      dictionary[property] = serializeObject(toSerialize[property]);\n    }\n    return dictionary;\n  }\n  return toSerialize;\n}\n/**\n * Utility function to create a K:V from a list of strings\n */\nfunction strEnum(o) {\n  var result = {};\n  for (var _i = 0, o_1 = o; _i < o_1.length; _i++) {\n    var key = o_1[_i];\n    result[key] = key;\n  }\n  return result;\n}\nexport var MapperType = strEnum([\"Base64Url\", \"Boolean\", \"ByteArray\", \"Composite\", \"Date\", \"DateTime\", \"DateTimeRfc1123\", \"Dictionary\", \"Enum\", \"Number\", \"Object\", \"Sequence\", \"String\", \"Stream\", \"TimeSpan\", \"UnixTime\"]);","map":{"version":3,"names":["base64","utils","Serializer","modelMappers","isXML","prototype","validateConstraints","mapper","value","objectName","failValidation","constraintName","constraintValue","Error","constraints","undefined","_a","ExclusiveMaximum","ExclusiveMinimum","InclusiveMaximum","InclusiveMinimum","MaxItems","MaxLength","MinItems","MinLength","MultipleOf","Pattern","UniqueItems","length","pattern","RegExp","match","some","item","i","ar","indexOf","serialize","object","payload","mapperType","type","name","serializedName","isConstant","defaultValue","required","nullable","serializeBasicTypes","enumMapper","serializeEnumType","allowedValues","serializeDateTypes","serializeByteArrayType","serializeBase64UrlType","serializeSequenceType","serializeDictionaryType","serializeCompositeType","deserialize","responseBody","xmlIsWrapped","deserializeCompositeType","parseFloat","isNaN","Date","unixTimeToDate","decodeString","base64UrlToByteArray","deserializeSequenceType","deserializeDictionaryType","trimEnd","str","ch","len","substr","bufferToBase64Url","buffer","Uint8Array","encodeByteArray","replace","valueOf","splitSerializeName","prop","classes","partialclass","subwords","split","_i","subwords_1","charAt","push","dateToUnixTime","d","Math","floor","getTime","n","typeName","isValidUuid","objectType","ArrayBuffer","isView","Blob","isPresent","toLowerCase","JSON","stringify","parse","toISOString","substring","toUTCString","isDuration","serializer","Array","isArray","elementType","element","tempArray","valueType","tempDictionary","Object","keys","key","resolveModelProperties","modelProps","modelProperties","className","modelMapper","getPolymorphicDiscriminatorRecursively","getPolymorphicMapper","_b","propertyMapper","readOnly","propName","parentObject","xmlName","xmlElementName","paths","pop","_c","paths_1","pathName","childObject","propertyObjectName","toSerialize","polymorphicDiscriminator","clientName","serializedValue","xmlIsAttribute","$","additionalPropertiesMapper","additionalProperties","propNames","clientPropName","isAdditionalProperty","every","pn","isSpecialXmlProperty","propertyName","includes","instance","handledPropertyNames","headerCollectionPrefix","dictionary","headerKey","startsWith","unwrappedProperty","isEmptyWrappedList","propertyInstance","res","_d","paths_2","arrayInstance","_e","_f","entries","_g","key_1","hasOwnProperty","responsePropName","_h","_j","polymorphicPropertyName","discriminatorName","discriminatorValue","uberParent","indexDiscriminator","polymorphicMapper","discriminators","getPolymorphicDiscriminatorSafely","serializeObject","array","property","strEnum","o","result","o_1","MapperType"],"sources":["C:\\repo\\wihy_ui\\client\\node_modules\\@azure\\ms-rest-js\\lib\\serializer.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\n\nimport * as base64 from \"./util/base64\";\nimport * as utils from \"./util/utils\";\n\nexport class Serializer {\n  constructor(\n    public readonly modelMappers: { [key: string]: any } = {},\n    public readonly isXML?: boolean\n  ) {}\n\n  validateConstraints(mapper: Mapper, value: any, objectName: string): void {\n    const failValidation = (constraintName: keyof MapperConstraints, constraintValue: any) => {\n      throw new Error(\n        `\"${objectName}\" with value \"${value}\" should satisfy the constraint \"${constraintName}\": ${constraintValue}.`\n      );\n    };\n    if (mapper.constraints && value != undefined) {\n      const {\n        ExclusiveMaximum,\n        ExclusiveMinimum,\n        InclusiveMaximum,\n        InclusiveMinimum,\n        MaxItems,\n        MaxLength,\n        MinItems,\n        MinLength,\n        MultipleOf,\n        Pattern,\n        UniqueItems,\n      } = mapper.constraints;\n      if (ExclusiveMaximum != undefined && value >= ExclusiveMaximum) {\n        failValidation(\"ExclusiveMaximum\", ExclusiveMaximum);\n      }\n      if (ExclusiveMinimum != undefined && value <= ExclusiveMinimum) {\n        failValidation(\"ExclusiveMinimum\", ExclusiveMinimum);\n      }\n      if (InclusiveMaximum != undefined && value > InclusiveMaximum) {\n        failValidation(\"InclusiveMaximum\", InclusiveMaximum);\n      }\n      if (InclusiveMinimum != undefined && value < InclusiveMinimum) {\n        failValidation(\"InclusiveMinimum\", InclusiveMinimum);\n      }\n      if (MaxItems != undefined && value.length > MaxItems) {\n        failValidation(\"MaxItems\", MaxItems);\n      }\n      if (MaxLength != undefined && value.length > MaxLength) {\n        failValidation(\"MaxLength\", MaxLength);\n      }\n      if (MinItems != undefined && value.length < MinItems) {\n        failValidation(\"MinItems\", MinItems);\n      }\n      if (MinLength != undefined && value.length < MinLength) {\n        failValidation(\"MinLength\", MinLength);\n      }\n      if (MultipleOf != undefined && value % MultipleOf !== 0) {\n        failValidation(\"MultipleOf\", MultipleOf);\n      }\n      if (Pattern) {\n        const pattern: RegExp = typeof Pattern === \"string\" ? new RegExp(Pattern) : Pattern;\n        if (typeof value !== \"string\" || value.match(pattern) === null) {\n          failValidation(\"Pattern\", Pattern);\n        }\n      }\n      if (\n        UniqueItems &&\n        value.some((item: any, i: number, ar: Array<any>) => ar.indexOf(item) !== i)\n      ) {\n        failValidation(\"UniqueItems\", UniqueItems);\n      }\n    }\n  }\n\n  /**\n   * Serialize the given object based on its metadata defined in the mapper\n   *\n   * @param {Mapper} mapper The mapper which defines the metadata of the serializable object\n   *\n   * @param {object|string|Array|number|boolean|Date|stream} object A valid Javascript object to be serialized\n   *\n   * @param {string} objectName Name of the serialized object\n   *\n   * @returns {object|string|Array|number|boolean|Date|stream} A valid serialized Javascript object\n   */\n  serialize(mapper: Mapper, object: any, objectName?: string): any {\n    let payload: any = {};\n    const mapperType = mapper.type.name as string;\n    if (!objectName) {\n      objectName = mapper.serializedName!;\n    }\n    if (mapperType.match(/^Sequence$/gi) !== null) {\n      payload = [];\n    }\n\n    if (mapper.isConstant) {\n      object = mapper.defaultValue;\n    }\n\n    // This table of allowed values should help explain\n    // the mapper.required and mapper.nullable properties.\n    // X means \"neither undefined or null are allowed\".\n    //           || required\n    //           || true      | false\n    //  nullable || ==========================\n    //      true || null      | undefined/null\n    //     false || X         | undefined\n    // undefined || X         | undefined/null\n\n    const { required, nullable } = mapper;\n\n    if (required && nullable && object === undefined) {\n      throw new Error(`${objectName} cannot be undefined.`);\n    }\n    if (required && !nullable && object == undefined) {\n      throw new Error(`${objectName} cannot be null or undefined.`);\n    }\n    if (!required && nullable === false && object === null) {\n      throw new Error(`${objectName} cannot be null.`);\n    }\n\n    if (object == undefined) {\n      payload = object;\n    } else {\n      // Validate Constraints if any\n      this.validateConstraints(mapper, object, objectName);\n      if (mapperType.match(/^any$/gi) !== null) {\n        payload = object;\n      } else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/gi) !== null) {\n        payload = serializeBasicTypes(mapperType, objectName, object);\n      } else if (mapperType.match(/^Enum$/gi) !== null) {\n        const enumMapper: EnumMapper = mapper as EnumMapper;\n        payload = serializeEnumType(objectName, enumMapper.type.allowedValues, object);\n      } else if (\n        mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/gi) !== null\n      ) {\n        payload = serializeDateTypes(mapperType, object, objectName);\n      } else if (mapperType.match(/^ByteArray$/gi) !== null) {\n        payload = serializeByteArrayType(objectName, object);\n      } else if (mapperType.match(/^Base64Url$/gi) !== null) {\n        payload = serializeBase64UrlType(objectName, object);\n      } else if (mapperType.match(/^Sequence$/gi) !== null) {\n        payload = serializeSequenceType(this, mapper as SequenceMapper, object, objectName);\n      } else if (mapperType.match(/^Dictionary$/gi) !== null) {\n        payload = serializeDictionaryType(this, mapper as DictionaryMapper, object, objectName);\n      } else if (mapperType.match(/^Composite$/gi) !== null) {\n        payload = serializeCompositeType(this, mapper as CompositeMapper, object, objectName);\n      }\n    }\n    return payload;\n  }\n\n  /**\n   * Deserialize the given object based on its metadata defined in the mapper\n   *\n   * @param {object} mapper The mapper which defines the metadata of the serializable object\n   *\n   * @param {object|string|Array|number|boolean|Date|stream} responseBody A valid Javascript entity to be deserialized\n   *\n   * @param {string} objectName Name of the deserialized object\n   *\n   * @returns {object|string|Array|number|boolean|Date|stream} A valid deserialized Javascript object\n   */\n  deserialize(mapper: Mapper, responseBody: any, objectName: string): any {\n    if (responseBody == undefined) {\n      if (this.isXML && mapper.type.name === \"Sequence\" && !mapper.xmlIsWrapped) {\n        // Edge case for empty XML non-wrapped lists. xml2js can't distinguish\n        // between the list being empty versus being missing,\n        // so let's do the more user-friendly thing and return an empty list.\n        responseBody = [];\n      }\n      // specifically check for undefined as default value can be a falsey value `0, \"\", false, null`\n      if (mapper.defaultValue !== undefined) {\n        responseBody = mapper.defaultValue;\n      }\n      return responseBody;\n    }\n\n    let payload: any;\n    const mapperType = mapper.type.name;\n    if (!objectName) {\n      objectName = mapper.serializedName!;\n    }\n\n    if (mapperType.match(/^Composite$/gi) !== null) {\n      payload = deserializeCompositeType(this, mapper as CompositeMapper, responseBody, objectName);\n    } else {\n      if (this.isXML) {\n        /**\n         * If the mapper specifies this as a non-composite type value but the responseBody contains\n         * both header (\"$\") and body (\"_\") properties, then just reduce the responseBody value to\n         * the body (\"_\") property.\n         */\n        if (responseBody[\"$\"] != undefined && responseBody[\"_\"] != undefined) {\n          responseBody = responseBody[\"_\"];\n        }\n      }\n\n      if (mapperType.match(/^Number$/gi) !== null) {\n        payload = parseFloat(responseBody);\n        if (isNaN(payload)) {\n          payload = responseBody;\n        }\n      } else if (mapperType.match(/^Boolean$/gi) !== null) {\n        if (responseBody === \"true\") {\n          payload = true;\n        } else if (responseBody === \"false\") {\n          payload = false;\n        } else {\n          payload = responseBody;\n        }\n      } else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/gi) !== null) {\n        payload = responseBody;\n      } else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/gi) !== null) {\n        payload = new Date(responseBody);\n      } else if (mapperType.match(/^UnixTime$/gi) !== null) {\n        payload = unixTimeToDate(responseBody);\n      } else if (mapperType.match(/^ByteArray$/gi) !== null) {\n        payload = base64.decodeString(responseBody);\n      } else if (mapperType.match(/^Base64Url$/gi) !== null) {\n        payload = base64UrlToByteArray(responseBody);\n      } else if (mapperType.match(/^Sequence$/gi) !== null) {\n        payload = deserializeSequenceType(this, mapper as SequenceMapper, responseBody, objectName);\n      } else if (mapperType.match(/^Dictionary$/gi) !== null) {\n        payload = deserializeDictionaryType(\n          this,\n          mapper as DictionaryMapper,\n          responseBody,\n          objectName\n        );\n      }\n    }\n\n    if (mapper.isConstant) {\n      payload = mapper.defaultValue;\n    }\n\n    return payload;\n  }\n}\n\nfunction trimEnd(str: string, ch: string) {\n  let len = str.length;\n  while (len - 1 >= 0 && str[len - 1] === ch) {\n    --len;\n  }\n  return str.substr(0, len);\n}\n\nfunction bufferToBase64Url(buffer: any): string | undefined {\n  if (!buffer) {\n    return undefined;\n  }\n  if (!(buffer instanceof Uint8Array)) {\n    throw new Error(`Please provide an input of type Uint8Array for converting to Base64Url.`);\n  }\n  // Uint8Array to Base64.\n  const str = base64.encodeByteArray(buffer);\n  // Base64 to Base64Url.\n  return trimEnd(str, \"=\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\n\nfunction base64UrlToByteArray(str: string): Uint8Array | undefined {\n  if (!str) {\n    return undefined;\n  }\n  if (str && typeof str.valueOf() !== \"string\") {\n    throw new Error(\"Please provide an input of type string for converting to Uint8Array\");\n  }\n  // Base64Url to Base64.\n  str = str.replace(/\\-/g, \"+\").replace(/\\_/g, \"/\");\n  // Base64 to Uint8Array.\n  return base64.decodeString(str);\n}\n\nfunction splitSerializeName(prop: string | undefined): string[] {\n  const classes: string[] = [];\n  let partialclass = \"\";\n  if (prop) {\n    const subwords = prop.split(\".\");\n\n    for (const item of subwords) {\n      if (item.charAt(item.length - 1) === \"\\\\\") {\n        partialclass += item.substr(0, item.length - 1) + \".\";\n      } else {\n        partialclass += item;\n        classes.push(partialclass);\n        partialclass = \"\";\n      }\n    }\n  }\n\n  return classes;\n}\n\nfunction dateToUnixTime(d: string | Date): number | undefined {\n  if (!d) {\n    return undefined;\n  }\n\n  if (typeof d.valueOf() === \"string\") {\n    d = new Date(d as string);\n  }\n  return Math.floor((d as Date).getTime() / 1000);\n}\n\nfunction unixTimeToDate(n: number): Date | undefined {\n  if (!n) {\n    return undefined;\n  }\n  return new Date(n * 1000);\n}\n\nfunction serializeBasicTypes(typeName: string, objectName: string, value: any): any {\n  if (value !== null && value !== undefined) {\n    if (typeName.match(/^Number$/gi) !== null) {\n      if (typeof value !== \"number\") {\n        throw new Error(`${objectName} with value ${value} must be of type number.`);\n      }\n    } else if (typeName.match(/^String$/gi) !== null) {\n      if (typeof value.valueOf() !== \"string\") {\n        throw new Error(`${objectName} with value \"${value}\" must be of type string.`);\n      }\n    } else if (typeName.match(/^Uuid$/gi) !== null) {\n      if (!(typeof value.valueOf() === \"string\" && utils.isValidUuid(value))) {\n        throw new Error(\n          `${objectName} with value \"${value}\" must be of type string and a valid uuid.`\n        );\n      }\n    } else if (typeName.match(/^Boolean$/gi) !== null) {\n      if (typeof value !== \"boolean\") {\n        throw new Error(`${objectName} with value ${value} must be of type boolean.`);\n      }\n    } else if (typeName.match(/^Stream$/gi) !== null) {\n      const objectType = typeof value;\n      if (\n        objectType !== \"string\" &&\n        objectType !== \"function\" &&\n        !(value instanceof ArrayBuffer) &&\n        !ArrayBuffer.isView(value) &&\n        !(typeof Blob === \"function\" && value instanceof Blob)\n      ) {\n        throw new Error(\n          `${objectName} must be a string, Blob, ArrayBuffer, ArrayBufferView, or a function returning NodeJS.ReadableStream.`\n        );\n      }\n    }\n  }\n  return value;\n}\n\nfunction serializeEnumType(objectName: string, allowedValues: Array<any>, value: any): any {\n  if (!allowedValues) {\n    throw new Error(\n      `Please provide a set of allowedValues to validate ${objectName} as an Enum Type.`\n    );\n  }\n  const isPresent = allowedValues.some((item) => {\n    if (typeof item.valueOf() === \"string\") {\n      return item.toLowerCase() === value.toLowerCase();\n    }\n    return item === value;\n  });\n  if (!isPresent) {\n    throw new Error(\n      `${value} is not a valid value for ${objectName}. The valid values are: ${JSON.stringify(\n        allowedValues\n      )}.`\n    );\n  }\n  return value;\n}\n\nfunction serializeByteArrayType(objectName: string, value: any): any {\n  if (value != undefined) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error(`${objectName} must be of type Uint8Array.`);\n    }\n    value = base64.encodeByteArray(value);\n  }\n  return value;\n}\n\nfunction serializeBase64UrlType(objectName: string, value: any): any {\n  if (value != undefined) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error(`${objectName} must be of type Uint8Array.`);\n    }\n    value = bufferToBase64Url(value);\n  }\n  return value;\n}\n\nfunction serializeDateTypes(typeName: string, value: any, objectName: string) {\n  if (value != undefined) {\n    if (typeName.match(/^Date$/gi) !== null) {\n      if (\n        !(\n          value instanceof Date ||\n          (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))\n        )\n      ) {\n        throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);\n      }\n      value =\n        value instanceof Date\n          ? value.toISOString().substring(0, 10)\n          : new Date(value).toISOString().substring(0, 10);\n    } else if (typeName.match(/^DateTime$/gi) !== null) {\n      if (\n        !(\n          value instanceof Date ||\n          (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))\n        )\n      ) {\n        throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);\n      }\n      value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();\n    } else if (typeName.match(/^DateTimeRfc1123$/gi) !== null) {\n      if (\n        !(\n          value instanceof Date ||\n          (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))\n        )\n      ) {\n        throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123 format.`);\n      }\n      value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();\n    } else if (typeName.match(/^UnixTime$/gi) !== null) {\n      if (\n        !(\n          value instanceof Date ||\n          (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))\n        )\n      ) {\n        throw new Error(\n          `${objectName} must be an instanceof Date or a string in RFC-1123/ISO8601 format ` +\n            `for it to be serialized in UnixTime/Epoch format.`\n        );\n      }\n      value = dateToUnixTime(value);\n    } else if (typeName.match(/^TimeSpan$/gi) !== null) {\n      if (!utils.isDuration(value)) {\n        throw new Error(\n          `${objectName} must be a string in ISO 8601 format. Instead was \"${value}\".`\n        );\n      }\n      value = value;\n    }\n  }\n  return value;\n}\n\nfunction serializeSequenceType(\n  serializer: Serializer,\n  mapper: SequenceMapper,\n  object: any,\n  objectName: string\n) {\n  if (!Array.isArray(object)) {\n    throw new Error(`${objectName} must be of type Array.`);\n  }\n  const elementType = mapper.type.element;\n  if (!elementType || typeof elementType !== \"object\") {\n    throw new Error(\n      `element\" metadata for an Array must be defined in the ` +\n        `mapper and it must of type \"object\" in ${objectName}.`\n    );\n  }\n  const tempArray = [];\n  for (let i = 0; i < object.length; i++) {\n    tempArray[i] = serializer.serialize(elementType, object[i], objectName);\n  }\n  return tempArray;\n}\n\nfunction serializeDictionaryType(\n  serializer: Serializer,\n  mapper: DictionaryMapper,\n  object: any,\n  objectName: string\n) {\n  if (typeof object !== \"object\") {\n    throw new Error(`${objectName} must be of type object.`);\n  }\n  const valueType = mapper.type.value;\n  if (!valueType || typeof valueType !== \"object\") {\n    throw new Error(\n      `\"value\" metadata for a Dictionary must be defined in the ` +\n        `mapper and it must of type \"object\" in ${objectName}.`\n    );\n  }\n  const tempDictionary: { [key: string]: any } = {};\n  for (const key of Object.keys(object)) {\n    tempDictionary[key] = serializer.serialize(valueType, object[key], objectName + \".\" + key);\n  }\n  return tempDictionary;\n}\n\n/**\n * Resolves a composite mapper's modelProperties.\n * @param serializer the serializer containing the entire set of mappers\n * @param mapper the composite mapper to resolve\n */\nfunction resolveModelProperties(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  objectName: string\n): { [propertyName: string]: Mapper } {\n  let modelProps = mapper.type.modelProperties;\n  if (!modelProps) {\n    const className = mapper.type.className;\n    if (!className) {\n      throw new Error(\n        `Class name for model \"${objectName}\" is not provided in the mapper \"${JSON.stringify(\n          mapper,\n          undefined,\n          2\n        )}\".`\n      );\n    }\n\n    const modelMapper = serializer.modelMappers[className];\n    if (!modelMapper) {\n      throw new Error(`mapper() cannot be null or undefined for model \"${className}\".`);\n    }\n    modelProps = modelMapper.type.modelProperties;\n    if (!modelProps) {\n      throw new Error(\n        `modelProperties cannot be null or undefined in the ` +\n          `mapper \"${JSON.stringify(\n            modelMapper\n          )}\" of type \"${className}\" for object \"${objectName}\".`\n      );\n    }\n  }\n\n  return modelProps;\n}\n\nfunction serializeCompositeType(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  object: any,\n  objectName: string\n) {\n  if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {\n    mapper = getPolymorphicMapper(serializer, mapper, object, \"clientName\");\n  }\n\n  if (object != undefined) {\n    const payload: any = {};\n    const modelProps = resolveModelProperties(serializer, mapper, objectName);\n    for (const key of Object.keys(modelProps)) {\n      const propertyMapper = modelProps[key];\n      if (propertyMapper.readOnly) {\n        continue;\n      }\n\n      let propName: string | undefined;\n      let parentObject: any = payload;\n      if (serializer.isXML) {\n        if (propertyMapper.xmlIsWrapped) {\n          propName = propertyMapper.xmlName;\n        } else {\n          propName = propertyMapper.xmlElementName || propertyMapper.xmlName;\n        }\n      } else {\n        const paths = splitSerializeName(propertyMapper.serializedName!);\n        propName = paths.pop();\n\n        for (const pathName of paths) {\n          const childObject = parentObject[pathName];\n          if (childObject == undefined && object[key] != undefined) {\n            parentObject[pathName] = {};\n          }\n          parentObject = parentObject[pathName];\n        }\n      }\n\n      if (parentObject != undefined) {\n        const propertyObjectName =\n          propertyMapper.serializedName !== \"\"\n            ? objectName + \".\" + propertyMapper.serializedName\n            : objectName;\n\n        let toSerialize = object[key];\n        const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);\n        if (\n          polymorphicDiscriminator &&\n          polymorphicDiscriminator.clientName === key &&\n          toSerialize == undefined\n        ) {\n          toSerialize = mapper.serializedName;\n        }\n\n        const serializedValue = serializer.serialize(\n          propertyMapper,\n          toSerialize,\n          propertyObjectName\n        );\n        if (serializedValue !== undefined && propName != undefined) {\n          if (propertyMapper.xmlIsAttribute) {\n            // $ is the key attributes are kept under in xml2js.\n            // This keeps things simple while preventing name collision\n            // with names in user documents.\n            parentObject.$ = parentObject.$ || {};\n            parentObject.$[propName] = serializedValue;\n          } else if (propertyMapper.xmlIsWrapped) {\n            parentObject[propName] = { [propertyMapper.xmlElementName!]: serializedValue };\n          } else {\n            parentObject[propName] = serializedValue;\n          }\n        }\n      }\n    }\n\n    const additionalPropertiesMapper = mapper.type.additionalProperties;\n    if (additionalPropertiesMapper) {\n      const propNames = Object.keys(modelProps);\n      for (const clientPropName in object) {\n        const isAdditionalProperty = propNames.every((pn) => pn !== clientPropName);\n        if (isAdditionalProperty) {\n          payload[clientPropName] = serializer.serialize(\n            additionalPropertiesMapper,\n            object[clientPropName],\n            objectName + '[\"' + clientPropName + '\"]'\n          );\n        }\n      }\n    }\n\n    return payload;\n  }\n  return object;\n}\n\nfunction isSpecialXmlProperty(propertyName: string): boolean {\n  return [\"$\", \"_\"].includes(propertyName);\n}\n\nfunction deserializeCompositeType(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  responseBody: any,\n  objectName: string\n): any {\n  if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {\n    mapper = getPolymorphicMapper(serializer, mapper, responseBody, \"serializedName\");\n  }\n\n  const modelProps = resolveModelProperties(serializer, mapper, objectName);\n  let instance: { [key: string]: any } = {};\n  const handledPropertyNames: string[] = [];\n\n  for (const key of Object.keys(modelProps)) {\n    const propertyMapper = modelProps[key];\n    const paths = splitSerializeName(modelProps[key].serializedName!);\n    handledPropertyNames.push(paths[0]);\n    const { serializedName, xmlName, xmlElementName } = propertyMapper;\n    let propertyObjectName = objectName;\n    if (serializedName !== \"\" && serializedName !== undefined) {\n      propertyObjectName = objectName + \".\" + serializedName;\n    }\n\n    const headerCollectionPrefix = (propertyMapper as DictionaryMapper).headerCollectionPrefix;\n    if (headerCollectionPrefix) {\n      const dictionary: any = {};\n      for (const headerKey of Object.keys(responseBody)) {\n        if (headerKey.startsWith(headerCollectionPrefix)) {\n          dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer.deserialize(\n            (propertyMapper as DictionaryMapper).type.value,\n            responseBody[headerKey],\n            propertyObjectName\n          );\n        }\n\n        handledPropertyNames.push(headerKey);\n      }\n      instance[key] = dictionary;\n    } else if (serializer.isXML) {\n      if (propertyMapper.xmlIsAttribute && responseBody.$) {\n        instance[key] = serializer.deserialize(\n          propertyMapper,\n          responseBody.$[xmlName!],\n          propertyObjectName\n        );\n      } else {\n        const propertyName = xmlElementName || xmlName || serializedName;\n        let unwrappedProperty = responseBody[propertyName!];\n        if (propertyMapper.xmlIsWrapped) {\n          unwrappedProperty = responseBody[xmlName!];\n          unwrappedProperty = unwrappedProperty && unwrappedProperty[xmlElementName!];\n\n          const isEmptyWrappedList = unwrappedProperty === undefined;\n          if (isEmptyWrappedList) {\n            unwrappedProperty = [];\n          }\n        }\n        instance[key] = serializer.deserialize(\n          propertyMapper,\n          unwrappedProperty,\n          propertyObjectName\n        );\n      }\n    } else {\n      // deserialize the property if it is present in the provided responseBody instance\n      let propertyInstance;\n      let res = responseBody;\n      // traversing the object step by step.\n      for (const item of paths) {\n        if (!res) break;\n        res = res[item];\n      }\n      propertyInstance = res;\n      const polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;\n      // checking that the model property name (key)(ex: \"fishtype\") and the\n      // clientName of the polymorphicDiscriminator {metadata} (ex: \"fishtype\")\n      // instead of the serializedName of the polymorphicDiscriminator (ex: \"fish.type\")\n      // is a better approach. The generator is not consistent with escaping '\\.' in the\n      // serializedName of the property (ex: \"fish\\.type\") that is marked as polymorphic discriminator\n      // and the serializedName of the metadata polymorphicDiscriminator (ex: \"fish.type\"). However,\n      // the clientName transformation of the polymorphicDiscriminator (ex: \"fishtype\") and\n      // the transformation of model property name (ex: \"fishtype\") is done consistently.\n      // Hence, it is a safer bet to rely on the clientName of the polymorphicDiscriminator.\n      if (\n        polymorphicDiscriminator &&\n        key === polymorphicDiscriminator.clientName &&\n        propertyInstance == undefined\n      ) {\n        propertyInstance = mapper.serializedName;\n      }\n\n      let serializedValue;\n      // paging\n      if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === \"\") {\n        propertyInstance = responseBody[key];\n        const arrayInstance = serializer.deserialize(\n          propertyMapper,\n          propertyInstance,\n          propertyObjectName\n        );\n        // Copy over any properties that have already been added into the instance, where they do\n        // not exist on the newly de-serialized array\n        for (const [key, value] of Object.entries(instance)) {\n          if (!arrayInstance.hasOwnProperty(key)) {\n            arrayInstance[key] = value;\n          }\n        }\n        instance = arrayInstance;\n      } else if (propertyInstance !== undefined || propertyMapper.defaultValue !== undefined) {\n        serializedValue = serializer.deserialize(\n          propertyMapper,\n          propertyInstance,\n          propertyObjectName\n        );\n        instance[key] = serializedValue;\n      }\n    }\n  }\n\n  const additionalPropertiesMapper = mapper.type.additionalProperties;\n  if (additionalPropertiesMapper) {\n    const isAdditionalProperty = (responsePropName: string) => {\n      for (const clientPropName in modelProps) {\n        const paths = splitSerializeName(modelProps[clientPropName].serializedName);\n        if (paths[0] === responsePropName) {\n          return false;\n        }\n      }\n      return true;\n    };\n\n    for (const responsePropName in responseBody) {\n      if (isAdditionalProperty(responsePropName)) {\n        instance[responsePropName] = serializer.deserialize(\n          additionalPropertiesMapper,\n          responseBody[responsePropName],\n          objectName + '[\"' + responsePropName + '\"]'\n        );\n      }\n    }\n  } else if (responseBody) {\n    for (const key of Object.keys(responseBody)) {\n      if (\n        instance[key] === undefined &&\n        !handledPropertyNames.includes(key) &&\n        !isSpecialXmlProperty(key)\n      ) {\n        instance[key] = responseBody[key];\n      }\n    }\n  }\n\n  return instance;\n}\n\nfunction deserializeDictionaryType(\n  serializer: Serializer,\n  mapper: DictionaryMapper,\n  responseBody: any,\n  objectName: string\n): any {\n  /*jshint validthis: true */\n  const value = mapper.type.value;\n  if (!value || typeof value !== \"object\") {\n    throw new Error(\n      `\"value\" metadata for a Dictionary must be defined in the ` +\n        `mapper and it must of type \"object\" in ${objectName}`\n    );\n  }\n  if (responseBody) {\n    const tempDictionary: { [key: string]: any } = {};\n    for (const key of Object.keys(responseBody)) {\n      tempDictionary[key] = serializer.deserialize(value, responseBody[key], objectName);\n    }\n    return tempDictionary;\n  }\n  return responseBody;\n}\n\nfunction deserializeSequenceType(\n  serializer: Serializer,\n  mapper: SequenceMapper,\n  responseBody: any,\n  objectName: string\n): any {\n  /*jshint validthis: true */\n  const element = mapper.type.element;\n  if (!element || typeof element !== \"object\") {\n    throw new Error(\n      `element\" metadata for an Array must be defined in the ` +\n        `mapper and it must of type \"object\" in ${objectName}`\n    );\n  }\n  if (responseBody) {\n    if (!Array.isArray(responseBody)) {\n      // xml2js will interpret a single element array as just the element, so force it to be an array\n      responseBody = [responseBody];\n    }\n\n    const tempArray = [];\n    for (let i = 0; i < responseBody.length; i++) {\n      tempArray[i] = serializer.deserialize(element, responseBody[i], `${objectName}[${i}]`);\n    }\n    return tempArray;\n  }\n  return responseBody;\n}\n\nfunction getPolymorphicMapper(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  object: any,\n  polymorphicPropertyName: \"clientName\" | \"serializedName\"\n): CompositeMapper {\n  const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);\n  if (polymorphicDiscriminator) {\n    const discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];\n    if (discriminatorName != undefined) {\n      const discriminatorValue = object[discriminatorName];\n      if (discriminatorValue != undefined) {\n        const typeName = mapper.type.uberParent || mapper.type.className;\n        const indexDiscriminator =\n          discriminatorValue === typeName\n            ? discriminatorValue\n            : typeName + \".\" + discriminatorValue;\n        const polymorphicMapper = serializer.modelMappers.discriminators[indexDiscriminator];\n        if (polymorphicMapper) {\n          mapper = polymorphicMapper;\n        }\n      }\n    }\n  }\n  return mapper;\n}\n\nfunction getPolymorphicDiscriminatorRecursively(\n  serializer: Serializer,\n  mapper: CompositeMapper\n): PolymorphicDiscriminator | undefined {\n  return (\n    mapper.type.polymorphicDiscriminator ||\n    getPolymorphicDiscriminatorSafely(serializer, mapper.type.uberParent) ||\n    getPolymorphicDiscriminatorSafely(serializer, mapper.type.className)\n  );\n}\n\nfunction getPolymorphicDiscriminatorSafely(serializer: Serializer, typeName?: string) {\n  return (\n    typeName &&\n    serializer.modelMappers[typeName] &&\n    serializer.modelMappers[typeName].type.polymorphicDiscriminator\n  );\n}\n\nexport interface MapperConstraints {\n  InclusiveMaximum?: number;\n  ExclusiveMaximum?: number;\n  InclusiveMinimum?: number;\n  ExclusiveMinimum?: number;\n  MaxLength?: number;\n  MinLength?: number;\n  Pattern?: RegExp;\n  MaxItems?: number;\n  MinItems?: number;\n  UniqueItems?: true;\n  MultipleOf?: number;\n}\n\nexport type MapperType =\n  | SimpleMapperType\n  | CompositeMapperType\n  | SequenceMapperType\n  | DictionaryMapperType\n  | EnumMapperType;\n\nexport interface SimpleMapperType {\n  name:\n    | \"Base64Url\"\n    | \"Boolean\"\n    | \"ByteArray\"\n    | \"Date\"\n    | \"DateTime\"\n    | \"DateTimeRfc1123\"\n    | \"Object\"\n    | \"Stream\"\n    | \"String\"\n    | \"TimeSpan\"\n    | \"UnixTime\"\n    | \"Uuid\"\n    | \"Number\"\n    | \"any\";\n}\n\nexport interface CompositeMapperType {\n  name: \"Composite\";\n\n  // Only one of the two below properties should be present.\n  // Use className to reference another type definition,\n  // and use modelProperties/additionalProperties when the reference to the other type has been resolved.\n  className?: string;\n\n  modelProperties?: { [propertyName: string]: Mapper };\n  additionalProperties?: Mapper;\n\n  uberParent?: string;\n  polymorphicDiscriminator?: PolymorphicDiscriminator;\n}\n\nexport interface SequenceMapperType {\n  name: \"Sequence\";\n  element: Mapper;\n}\n\nexport interface DictionaryMapperType {\n  name: \"Dictionary\";\n  value: Mapper;\n}\n\nexport interface EnumMapperType {\n  name: \"Enum\";\n  allowedValues: any[];\n}\n\nexport interface BaseMapper {\n  xmlName?: string;\n  xmlIsAttribute?: boolean;\n  xmlElementName?: string;\n  xmlIsWrapped?: boolean;\n  readOnly?: boolean;\n  isConstant?: boolean;\n  required?: boolean;\n  nullable?: boolean;\n  serializedName?: string;\n  type: MapperType;\n  defaultValue?: any;\n  constraints?: MapperConstraints;\n}\n\nexport type Mapper = BaseMapper | CompositeMapper | SequenceMapper | DictionaryMapper | EnumMapper;\n\nexport interface PolymorphicDiscriminator {\n  serializedName: string;\n  clientName: string;\n  [key: string]: string;\n}\n\nexport interface CompositeMapper extends BaseMapper {\n  type: CompositeMapperType;\n}\n\nexport interface SequenceMapper extends BaseMapper {\n  type: SequenceMapperType;\n}\n\nexport interface DictionaryMapper extends BaseMapper {\n  type: DictionaryMapperType;\n  headerCollectionPrefix?: string;\n}\n\nexport interface EnumMapper extends BaseMapper {\n  type: EnumMapperType;\n}\n\nexport interface UrlParameterValue {\n  value: string;\n  skipUrlEncoding: boolean;\n}\n\n// TODO: why is this here?\nexport function serializeObject(toSerialize: any): any {\n  if (toSerialize == undefined) return undefined;\n  if (toSerialize instanceof Uint8Array) {\n    toSerialize = base64.encodeByteArray(toSerialize);\n    return toSerialize;\n  } else if (toSerialize instanceof Date) {\n    return toSerialize.toISOString();\n  } else if (Array.isArray(toSerialize)) {\n    const array = [];\n    for (let i = 0; i < toSerialize.length; i++) {\n      array.push(serializeObject(toSerialize[i]));\n    }\n    return array;\n  } else if (typeof toSerialize === \"object\") {\n    const dictionary: { [key: string]: any } = {};\n    for (const property in toSerialize) {\n      dictionary[property] = serializeObject(toSerialize[property]);\n    }\n    return dictionary;\n  }\n  return toSerialize;\n}\n\n/**\n * Utility function to create a K:V from a list of strings\n */\nfunction strEnum<T extends string>(o: Array<T>): { [K in T]: K } {\n  const result: any = {};\n  for (const key of o) {\n    result[key] = key;\n  }\n  return result;\n}\n\nexport const MapperType = strEnum([\n  \"Base64Url\",\n  \"Boolean\",\n  \"ByteArray\",\n  \"Composite\",\n  \"Date\",\n  \"DateTime\",\n  \"DateTimeRfc1123\",\n  \"Dictionary\",\n  \"Enum\",\n  \"Number\",\n  \"Object\",\n  \"Sequence\",\n  \"String\",\n  \"Stream\",\n  \"TimeSpan\",\n  \"UnixTime\",\n]);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}