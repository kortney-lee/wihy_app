{"ast":null,"code":"/**\r\n * Chat Service - Dedicated service for ChatWidget functionality\r\n * Connects to http://localhost:8000 with direct chat endpoint (no session required)\r\n * Sessions are optional and only used if they exist\r\n */\n\nconst CHAT_API_BASE = 'http://localhost:8000';\nclass ChatService {\n  constructor() {\n    this.currentSessionId = null;\n    this.conversationId = null;\n    this.userProfile = void 0;\n  }\n  /**\r\n   * Send a message using the direct chat endpoint (no session required)\r\n   * This is the primary method for simple health questions\r\n   */\n  async sendDirectMessage(message, userProfile) {\n    try {\n      var _analysis, _analysis2;\n      console.log('üîç CHAT SERVICE: Sending message');\n\n      // Add unique identifier to break backend caching while preserving message meaning\n      const timestamp = Date.now();\n      const uniqueId = Math.random().toString(36).substring(7);\n\n      // Add the unique elements at the end in a way that won't affect the AI's response\n      const uniqueMessage = `${message}\\n\\n[System: Request ID ${uniqueId} at ${timestamp}]`;\n\n      // Always use /chat endpoint for ChatWidget conversations\n      const endpoint = 'chat';\n      const request = {\n        message: uniqueMessage,\n        conversation_id: this.conversationId,\n        user_profile: userProfile\n      };\n      console.log('üîç CHAT SERVICE: Sending unique message:', {\n        originalMessage: message,\n        uniqueMessage: uniqueMessage.substring(0, 100) + '...',\n        timestamp,\n        uniqueId,\n        endpoint: 'chat'\n      });\n      const response = await fetch(`${CHAT_API_BASE}/chat?t=${timestamp}&r=${uniqueId}`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Cache-Control': 'no-cache, no-store, must-revalidate',\n          'Pragma': 'no-cache',\n          'Expires': '0'\n        },\n        body: JSON.stringify(request)\n      });\n      if (!response.ok) {\n        throw new Error(`Failed to send message: ${response.status} ${response.statusText}`);\n      }\n      const data = await response.json();\n      console.log('üîç CHAT SERVICE: Response received from /chat endpoint');\n      console.log('üîç CHAT SERVICE: Backend response structure:', {\n        hasAnalysis: !!data.analysis,\n        hasSummary: !!((_analysis = data.analysis) !== null && _analysis !== void 0 && _analysis.summary),\n        hasRecommendations: !!((_analysis2 = data.analysis) !== null && _analysis2 !== void 0 && _analysis2.recommendations),\n        hasResponse: !!data.response,\n        responseKeys: Object.keys(data),\n        analysisKeys: data.analysis ? Object.keys(data.analysis) : []\n      });\n\n      // Store conversation ID for continuity (if provided)\n      if (data.session_token) {\n        this.conversationId = data.session_token;\n      }\n      return data;\n    } catch (error) {\n      console.error('Chat service direct message error:', error);\n      return {\n        success: false,\n        response: 'Failed to send message',\n        error: error instanceof Error ? error.message : 'Unknown error'\n      };\n    }\n  }\n\n  /**\r\n   * Send a message using session-based endpoint (optional, advanced features)\r\n   * Only used if a session already exists\r\n   */\n  async sendSessionMessage(message, messageType = 'health_chat', useCustomModel = false) {\n    if (!this.currentSessionId) {\n      console.log('üîç CHAT SERVICE: No session available, falling back to direct message');\n      return null;\n    }\n    try {\n      var _data$response;\n      console.log('üîç CHAT SERVICE: Sending session message:', {\n        sessionId: this.currentSessionId,\n        message: message.substring(0, 100) + '...',\n        messageType,\n        useCustomModel\n      });\n      const request = {\n        session_id: this.currentSessionId,\n        message: message,\n        message_type: messageType,\n        use_custom_model: useCustomModel\n      };\n      const response = await fetch(`${CHAT_API_BASE}/api/chat/send-message`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(request)\n      });\n      if (!response.ok) {\n        throw new Error(`Failed to send session message: ${response.status} ${response.statusText}`);\n      }\n      const data = await response.json();\n      console.log('üîç CHAT SERVICE: Session message response:', {\n        success: data.success,\n        messageId: data.message_id,\n        modelUsed: data.model_used,\n        confidenceScore: data.confidence_score,\n        responseTime: data.response_time_ms,\n        responsePreview: ((_data$response = data.response) === null || _data$response === void 0 ? void 0 : _data$response.substring(0, 100)) + '...'\n      });\n      return data;\n    } catch (error) {\n      console.error('Chat service session message error:', error);\n      return {\n        success: false,\n        message: 'Failed to send session message',\n        error: error instanceof Error ? error.message : 'Unknown error'\n      };\n    }\n  }\n\n  /**\r\n   * Primary send message method - tries session first, falls back to direct\r\n   */\n  async sendMessage(message, userProfile, useCustomModel = false) {\n    // Try session-based chat first if session exists\n    if (this.currentSessionId) {\n      const sessionResponse = await this.sendSessionMessage(message, 'health_chat', useCustomModel);\n      if (sessionResponse !== null && sessionResponse !== void 0 && sessionResponse.success) {\n        return sessionResponse;\n      }\n    }\n\n    // Fall back to direct chat (no session required)\n    return await this.sendDirectMessage(message, userProfile);\n  }\n\n  /**\r\n   * Set an existing session ID (optional)\r\n   */\n  setSessionId(sessionId) {\n    this.currentSessionId = sessionId;\n    console.log('üîç CHAT SERVICE: Session ID set:', sessionId);\n  }\n\n  /**\r\n   * Clear current session - will use direct chat\r\n   */\n  clearSession() {\n    this.currentSessionId = null;\n    this.conversationId = null;\n    console.log('üîç CHAT SERVICE: Session cleared, using direct chat');\n  }\n\n  /**\r\n   * Get current session ID (may be null)\r\n   */\n  getCurrentSessionId() {\n    return this.currentSessionId;\n  }\n\n  /**\r\n   * Get current conversation ID for direct chat continuity\r\n   */\n  getConversationId() {\n    return this.conversationId;\n  }\n\n  /**\r\n   * Set user profile for personalized responses in direct chat\r\n   */\n  setUserProfile(profile) {\n    this.userProfile = profile;\n  }\n  /**\r\n   * Send message with current user profile\r\n   */\n  async sendMessageWithProfile(message) {\n    return await this.sendMessage(message, this.userProfile);\n  }\n}\n\n// Create and export singleton instance\nexport const chatService = new ChatService();\n\n// Export for type usage\nexport default chatService;","map":{"version":3,"names":["CHAT_API_BASE","ChatService","constructor","currentSessionId","conversationId","userProfile","sendDirectMessage","message","_analysis","_analysis2","console","log","timestamp","Date","now","uniqueId","Math","random","toString","substring","uniqueMessage","endpoint","request","conversation_id","user_profile","originalMessage","response","fetch","method","headers","body","JSON","stringify","ok","Error","status","statusText","data","json","hasAnalysis","analysis","hasSummary","summary","hasRecommendations","recommendations","hasResponse","responseKeys","Object","keys","analysisKeys","session_token","error","success","sendSessionMessage","messageType","useCustomModel","_data$response","sessionId","session_id","message_type","use_custom_model","messageId","message_id","modelUsed","model_used","confidenceScore","confidence_score","responseTime","response_time_ms","responsePreview","sendMessage","sessionResponse","setSessionId","clearSession","getCurrentSessionId","getConversationId","setUserProfile","profile","sendMessageWithProfile","chatService"],"sources":["C:/repo/wihy_ui/client/src/services/chatService.ts"],"sourcesContent":["/**\r\n * Chat Service - Dedicated service for ChatWidget functionality\r\n * Connects to http://localhost:8000 with direct chat endpoint (no session required)\r\n * Sessions are optional and only used if they exist\r\n */\r\n\r\nconst CHAT_API_BASE = 'http://localhost:8000';\r\n\r\nexport interface ChatRequest {\r\n  message: string;\r\n  conversation_id?: string;\r\n  user_profile?: Record<string, any>;\r\n}\r\n\r\nexport interface ChatResponse {\r\n  success: boolean;\r\n  response: string;\r\n  model_used?: string;\r\n  confidence_score?: number;\r\n  response_time_ms?: number;\r\n  citations?: string[];\r\n  session_token?: string;\r\n  message?: string;\r\n  error?: string;\r\n}\r\n\r\nexport interface ChatSession {\r\n  session_id: string;\r\n  session_name?: string;\r\n  created_at: string;\r\n  user_id: string;\r\n}\r\n\r\nexport interface ChatMessageRequest {\r\n  session_id: string;\r\n  message: string;\r\n  message_type?: string;\r\n  use_custom_model?: boolean;\r\n}\r\n\r\nexport interface ChatMessageResponse {\r\n  success: boolean;\r\n  message_id?: string;\r\n  response?: string;\r\n  model_used?: string;\r\n  confidence_score?: number;\r\n  response_time_ms?: number;\r\n  citations?: string[];\r\n  message: string;\r\n  error?: string;\r\n}\r\n\r\nclass ChatService {\r\n  private currentSessionId: string | null = null;\r\n  private conversationId: string | null = null;\r\n\r\n  /**\r\n   * Send a message using the direct chat endpoint (no session required)\r\n   * This is the primary method for simple health questions\r\n   */\r\n  async sendDirectMessage(\r\n    message: string, \r\n    userProfile?: Record<string, any>\r\n  ): Promise<ChatResponse | null> {\r\n    try {\r\n      console.log('üîç CHAT SERVICE: Sending message');\r\n\r\n      // Add unique identifier to break backend caching while preserving message meaning\r\n      const timestamp = Date.now();\r\n      const uniqueId = Math.random().toString(36).substring(7);\r\n      \r\n      // Add the unique elements at the end in a way that won't affect the AI's response\r\n      const uniqueMessage = `${message}\\n\\n[System: Request ID ${uniqueId} at ${timestamp}]`;\r\n      \r\n      // Always use /chat endpoint for ChatWidget conversations\r\n      const endpoint = 'chat';\r\n      \r\n      const request = {\r\n        message: uniqueMessage,\r\n        conversation_id: this.conversationId,\r\n        user_profile: userProfile\r\n      };\r\n\r\n      console.log('üîç CHAT SERVICE: Sending unique message:', {\r\n        originalMessage: message,\r\n        uniqueMessage: uniqueMessage.substring(0, 100) + '...',\r\n        timestamp,\r\n        uniqueId,\r\n        endpoint: 'chat'\r\n      });\r\n\r\n      const response = await fetch(`${CHAT_API_BASE}/chat?t=${timestamp}&r=${uniqueId}`, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n          'Cache-Control': 'no-cache, no-store, must-revalidate',\r\n          'Pragma': 'no-cache',\r\n          'Expires': '0'\r\n        },\r\n        body: JSON.stringify(request)\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error(`Failed to send message: ${response.status} ${response.statusText}`);\r\n      }\r\n\r\n      const data: ChatResponse = await response.json();\r\n\r\n      console.log('üîç CHAT SERVICE: Response received from /chat endpoint');\r\n      console.log('üîç CHAT SERVICE: Backend response structure:', {\r\n        hasAnalysis: !!(data as any).analysis,\r\n        hasSummary: !!(data as any).analysis?.summary,\r\n        hasRecommendations: !!(data as any).analysis?.recommendations,\r\n        hasResponse: !!data.response,\r\n        responseKeys: Object.keys(data),\r\n        analysisKeys: (data as any).analysis ? Object.keys((data as any).analysis) : []\r\n      });\r\n\r\n      // Store conversation ID for continuity (if provided)\r\n      if (data.session_token) {\r\n        this.conversationId = data.session_token;\r\n      }\r\n\r\n      return data;\r\n\r\n    } catch (error) {\r\n      console.error('Chat service direct message error:', error);\r\n      return {\r\n        success: false,\r\n        response: 'Failed to send message',\r\n        error: error instanceof Error ? error.message : 'Unknown error'\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Send a message using session-based endpoint (optional, advanced features)\r\n   * Only used if a session already exists\r\n   */\r\n  async sendSessionMessage(\r\n    message: string, \r\n    messageType: string = 'health_chat',\r\n    useCustomModel: boolean = false\r\n  ): Promise<ChatMessageResponse | null> {\r\n    if (!this.currentSessionId) {\r\n      console.log('üîç CHAT SERVICE: No session available, falling back to direct message');\r\n      return null;\r\n    }\r\n\r\n    try {\r\n      console.log('üîç CHAT SERVICE: Sending session message:', {\r\n        sessionId: this.currentSessionId,\r\n        message: message.substring(0, 100) + '...',\r\n        messageType,\r\n        useCustomModel\r\n      });\r\n\r\n      const request: ChatMessageRequest = {\r\n        session_id: this.currentSessionId,\r\n        message: message,\r\n        message_type: messageType,\r\n        use_custom_model: useCustomModel\r\n      };\r\n\r\n      const response = await fetch(`${CHAT_API_BASE}/api/chat/send-message`, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify(request)\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error(`Failed to send session message: ${response.status} ${response.statusText}`);\r\n      }\r\n\r\n      const data: ChatMessageResponse = await response.json();\r\n\r\n      console.log('üîç CHAT SERVICE: Session message response:', {\r\n        success: data.success,\r\n        messageId: data.message_id,\r\n        modelUsed: data.model_used,\r\n        confidenceScore: data.confidence_score,\r\n        responseTime: data.response_time_ms,\r\n        responsePreview: data.response?.substring(0, 100) + '...'\r\n      });\r\n\r\n      return data;\r\n\r\n    } catch (error) {\r\n      console.error('Chat service session message error:', error);\r\n      return {\r\n        success: false,\r\n        message: 'Failed to send session message',\r\n        error: error instanceof Error ? error.message : 'Unknown error'\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Primary send message method - tries session first, falls back to direct\r\n   */\r\n  async sendMessage(\r\n    message: string, \r\n    userProfile?: Record<string, any>,\r\n    useCustomModel: boolean = false\r\n  ): Promise<ChatResponse | ChatMessageResponse | null> {\r\n    // Try session-based chat first if session exists\r\n    if (this.currentSessionId) {\r\n      const sessionResponse = await this.sendSessionMessage(message, 'health_chat', useCustomModel);\r\n      if (sessionResponse?.success) {\r\n        return sessionResponse;\r\n      }\r\n    }\r\n\r\n    // Fall back to direct chat (no session required)\r\n    return await this.sendDirectMessage(message, userProfile);\r\n  }\r\n\r\n  /**\r\n   * Set an existing session ID (optional)\r\n   */\r\n  setSessionId(sessionId: string): void {\r\n    this.currentSessionId = sessionId;\r\n    console.log('üîç CHAT SERVICE: Session ID set:', sessionId);\r\n  }\r\n\r\n  /**\r\n   * Clear current session - will use direct chat\r\n   */\r\n  clearSession(): void {\r\n    this.currentSessionId = null;\r\n    this.conversationId = null;\r\n    console.log('üîç CHAT SERVICE: Session cleared, using direct chat');\r\n  }\r\n\r\n  /**\r\n   * Get current session ID (may be null)\r\n   */\r\n  getCurrentSessionId(): string | null {\r\n    return this.currentSessionId;\r\n  }\r\n\r\n  /**\r\n   * Get current conversation ID for direct chat continuity\r\n   */\r\n  getConversationId(): string | null {\r\n    return this.conversationId;\r\n  }\r\n\r\n  /**\r\n   * Set user profile for personalized responses in direct chat\r\n   */\r\n  setUserProfile(profile: Record<string, any>): void {\r\n    this.userProfile = profile;\r\n  }\r\n\r\n  private userProfile?: Record<string, any>;\r\n\r\n  /**\r\n   * Send message with current user profile\r\n   */\r\n  async sendMessageWithProfile(message: string): Promise<ChatResponse | ChatMessageResponse | null> {\r\n    return await this.sendMessage(message, this.userProfile);\r\n  }\r\n}\r\n\r\n// Create and export singleton instance\r\nexport const chatService = new ChatService();\r\n\r\n// Export for type usage\r\nexport default chatService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}