{"ast":null,"code":"/**\r\n * Chat Service - Dedicated service for ChatWidget functionality\r\n * Connects to http://localhost:8000 with direct chat endpoint (no session required)\r\n * Sessions are optional and only used if they exist\r\n */\n\nconst CHAT_API_BASE = 'http://localhost:8000';\nclass ChatService {\n  constructor() {\n    this.currentSessionId = null;\n    this.conversationId = null;\n    this.userProfile = void 0;\n  }\n  /**\r\n   * Send a message using the direct chat endpoint (no session required)\r\n   * This is the primary method for simple health questions\r\n   */\n  async sendDirectMessage(message, userProfile) {\n    try {\n      console.log('üîç CHAT SERVICE: Sending message');\n\n      // Add unique identifier to break backend caching while preserving message meaning\n      const timestamp = Date.now();\n      const uniqueId = Math.random().toString(36).substring(7);\n\n      // Add the unique elements at the end in a way that won't affect the AI's response\n      const uniqueMessage = `${message}\\n\\n[System: Request ID ${uniqueId} at ${timestamp}]`;\n      const request = {\n        message: uniqueMessage,\n        conversation_id: undefined,\n        // Force new conversation for each message to prevent caching\n        user_profile: userProfile\n      };\n      console.log('üîç CHAT SERVICE: Sending unique message:', {\n        originalMessage: message,\n        uniqueMessage: uniqueMessage.substring(0, 100) + '...',\n        timestamp,\n        uniqueId\n      });\n      const response = await fetch(`${CHAT_API_BASE}/ask?t=${timestamp}&r=${uniqueId}`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Cache-Control': 'no-cache, no-store, must-revalidate',\n          'Pragma': 'no-cache',\n          'Expires': '0'\n        },\n        body: JSON.stringify(request)\n      });\n      if (!response.ok) {\n        throw new Error(`Failed to send message: ${response.status} ${response.statusText}`);\n      }\n      const data = await response.json();\n      console.log('üîç CHAT SERVICE: Response received');\n\n      // Store conversation ID for continuity\n      if (data.session_token) {\n        this.conversationId = data.session_token;\n      }\n      return data;\n    } catch (error) {\n      console.error('Chat service direct message error:', error);\n      return {\n        success: false,\n        response: 'Failed to send message',\n        error: error instanceof Error ? error.message : 'Unknown error'\n      };\n    }\n  }\n\n  /**\r\n   * Send a message using session-based endpoint (optional, advanced features)\r\n   * Only used if a session already exists\r\n   */\n  async sendSessionMessage(message, messageType = 'health_chat', useCustomModel = false) {\n    if (!this.currentSessionId) {\n      console.log('üîç CHAT SERVICE: No session available, falling back to direct message');\n      return null;\n    }\n    try {\n      var _data$response;\n      console.log('üîç CHAT SERVICE: Sending session message:', {\n        sessionId: this.currentSessionId,\n        message: message.substring(0, 100) + '...',\n        messageType,\n        useCustomModel\n      });\n      const request = {\n        session_id: this.currentSessionId,\n        message: message,\n        message_type: messageType,\n        use_custom_model: useCustomModel\n      };\n      const response = await fetch(`${CHAT_API_BASE}/api/chat/send-message`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(request)\n      });\n      if (!response.ok) {\n        throw new Error(`Failed to send session message: ${response.status} ${response.statusText}`);\n      }\n      const data = await response.json();\n      console.log('üîç CHAT SERVICE: Session message response:', {\n        success: data.success,\n        messageId: data.message_id,\n        modelUsed: data.model_used,\n        confidenceScore: data.confidence_score,\n        responseTime: data.response_time_ms,\n        responsePreview: ((_data$response = data.response) === null || _data$response === void 0 ? void 0 : _data$response.substring(0, 100)) + '...'\n      });\n      return data;\n    } catch (error) {\n      console.error('Chat service session message error:', error);\n      return {\n        success: false,\n        message: 'Failed to send session message',\n        error: error instanceof Error ? error.message : 'Unknown error'\n      };\n    }\n  }\n\n  /**\r\n   * Primary send message method - tries session first, falls back to direct\r\n   */\n  async sendMessage(message, userProfile, useCustomModel = false) {\n    // Try session-based chat first if session exists\n    if (this.currentSessionId) {\n      const sessionResponse = await this.sendSessionMessage(message, 'health_chat', useCustomModel);\n      if (sessionResponse !== null && sessionResponse !== void 0 && sessionResponse.success) {\n        return sessionResponse;\n      }\n    }\n\n    // Fall back to direct chat (no session required)\n    return await this.sendDirectMessage(message, userProfile);\n  }\n\n  /**\r\n   * Set an existing session ID (optional)\r\n   */\n  setSessionId(sessionId) {\n    this.currentSessionId = sessionId;\n    console.log('üîç CHAT SERVICE: Session ID set:', sessionId);\n  }\n\n  /**\r\n   * Clear current session - will use direct chat\r\n   */\n  clearSession() {\n    this.currentSessionId = null;\n    this.conversationId = null;\n    console.log('üîç CHAT SERVICE: Session cleared, using direct chat');\n  }\n\n  /**\r\n   * Get current session ID (may be null)\r\n   */\n  getCurrentSessionId() {\n    return this.currentSessionId;\n  }\n\n  /**\r\n   * Get current conversation ID for direct chat continuity\r\n   */\n  getConversationId() {\n    return this.conversationId;\n  }\n\n  /**\r\n   * Set user profile for personalized responses in direct chat\r\n   */\n  setUserProfile(profile) {\n    this.userProfile = profile;\n  }\n  /**\r\n   * Send message with current user profile\r\n   */\n  async sendMessageWithProfile(message) {\n    return await this.sendMessage(message, this.userProfile);\n  }\n}\n\n// Create and export singleton instance\nexport const chatService = new ChatService();\n\n// Export for type usage\nexport default chatService;","map":{"version":3,"names":["CHAT_API_BASE","ChatService","constructor","currentSessionId","conversationId","userProfile","sendDirectMessage","message","console","log","timestamp","Date","now","uniqueId","Math","random","toString","substring","uniqueMessage","request","conversation_id","undefined","user_profile","originalMessage","response","fetch","method","headers","body","JSON","stringify","ok","Error","status","statusText","data","json","session_token","error","success","sendSessionMessage","messageType","useCustomModel","_data$response","sessionId","session_id","message_type","use_custom_model","messageId","message_id","modelUsed","model_used","confidenceScore","confidence_score","responseTime","response_time_ms","responsePreview","sendMessage","sessionResponse","setSessionId","clearSession","getCurrentSessionId","getConversationId","setUserProfile","profile","sendMessageWithProfile","chatService"],"sources":["C:/repo/wihy_ui/client/src/services/chatService.ts"],"sourcesContent":["/**\r\n * Chat Service - Dedicated service for ChatWidget functionality\r\n * Connects to http://localhost:8000 with direct chat endpoint (no session required)\r\n * Sessions are optional and only used if they exist\r\n */\r\n\r\nconst CHAT_API_BASE = 'http://localhost:8000';\r\n\r\nexport interface ChatRequest {\r\n  message: string;\r\n  conversation_id?: string;\r\n  user_profile?: Record<string, any>;\r\n}\r\n\r\nexport interface ChatResponse {\r\n  success: boolean;\r\n  response: string;\r\n  model_used?: string;\r\n  confidence_score?: number;\r\n  response_time_ms?: number;\r\n  citations?: string[];\r\n  session_token?: string;\r\n  message?: string;\r\n  error?: string;\r\n}\r\n\r\nexport interface ChatSession {\r\n  session_id: string;\r\n  session_name?: string;\r\n  created_at: string;\r\n  user_id: string;\r\n}\r\n\r\nexport interface ChatMessageRequest {\r\n  session_id: string;\r\n  message: string;\r\n  message_type?: string;\r\n  use_custom_model?: boolean;\r\n}\r\n\r\nexport interface ChatMessageResponse {\r\n  success: boolean;\r\n  message_id?: string;\r\n  response?: string;\r\n  model_used?: string;\r\n  confidence_score?: number;\r\n  response_time_ms?: number;\r\n  citations?: string[];\r\n  message: string;\r\n  error?: string;\r\n}\r\n\r\nclass ChatService {\r\n  private currentSessionId: string | null = null;\r\n  private conversationId: string | null = null;\r\n\r\n  /**\r\n   * Send a message using the direct chat endpoint (no session required)\r\n   * This is the primary method for simple health questions\r\n   */\r\n  async sendDirectMessage(\r\n    message: string, \r\n    userProfile?: Record<string, any>\r\n  ): Promise<ChatResponse | null> {\r\n    try {\r\n      console.log('üîç CHAT SERVICE: Sending message');\r\n\r\n      // Add unique identifier to break backend caching while preserving message meaning\r\n      const timestamp = Date.now();\r\n      const uniqueId = Math.random().toString(36).substring(7);\r\n      \r\n      // Add the unique elements at the end in a way that won't affect the AI's response\r\n      const uniqueMessage = `${message}\\n\\n[System: Request ID ${uniqueId} at ${timestamp}]`;\r\n      \r\n      const request: ChatRequest = {\r\n        message: uniqueMessage,\r\n        conversation_id: undefined, // Force new conversation for each message to prevent caching\r\n        user_profile: userProfile\r\n      };\r\n\r\n      console.log('üîç CHAT SERVICE: Sending unique message:', {\r\n        originalMessage: message,\r\n        uniqueMessage: uniqueMessage.substring(0, 100) + '...',\r\n        timestamp,\r\n        uniqueId\r\n      });\r\n\r\n      const response = await fetch(`${CHAT_API_BASE}/ask?t=${timestamp}&r=${uniqueId}`, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n          'Cache-Control': 'no-cache, no-store, must-revalidate',\r\n          'Pragma': 'no-cache',\r\n          'Expires': '0'\r\n        },\r\n        body: JSON.stringify(request)\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error(`Failed to send message: ${response.status} ${response.statusText}`);\r\n      }\r\n\r\n      const data: ChatResponse = await response.json();\r\n\r\n      console.log('üîç CHAT SERVICE: Response received');\r\n\r\n      // Store conversation ID for continuity\r\n      if (data.session_token) {\r\n        this.conversationId = data.session_token;\r\n      }\r\n\r\n      return data;\r\n\r\n    } catch (error) {\r\n      console.error('Chat service direct message error:', error);\r\n      return {\r\n        success: false,\r\n        response: 'Failed to send message',\r\n        error: error instanceof Error ? error.message : 'Unknown error'\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Send a message using session-based endpoint (optional, advanced features)\r\n   * Only used if a session already exists\r\n   */\r\n  async sendSessionMessage(\r\n    message: string, \r\n    messageType: string = 'health_chat',\r\n    useCustomModel: boolean = false\r\n  ): Promise<ChatMessageResponse | null> {\r\n    if (!this.currentSessionId) {\r\n      console.log('üîç CHAT SERVICE: No session available, falling back to direct message');\r\n      return null;\r\n    }\r\n\r\n    try {\r\n      console.log('üîç CHAT SERVICE: Sending session message:', {\r\n        sessionId: this.currentSessionId,\r\n        message: message.substring(0, 100) + '...',\r\n        messageType,\r\n        useCustomModel\r\n      });\r\n\r\n      const request: ChatMessageRequest = {\r\n        session_id: this.currentSessionId,\r\n        message: message,\r\n        message_type: messageType,\r\n        use_custom_model: useCustomModel\r\n      };\r\n\r\n      const response = await fetch(`${CHAT_API_BASE}/api/chat/send-message`, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify(request)\r\n      });\r\n\r\n      if (!response.ok) {\r\n        throw new Error(`Failed to send session message: ${response.status} ${response.statusText}`);\r\n      }\r\n\r\n      const data: ChatMessageResponse = await response.json();\r\n\r\n      console.log('üîç CHAT SERVICE: Session message response:', {\r\n        success: data.success,\r\n        messageId: data.message_id,\r\n        modelUsed: data.model_used,\r\n        confidenceScore: data.confidence_score,\r\n        responseTime: data.response_time_ms,\r\n        responsePreview: data.response?.substring(0, 100) + '...'\r\n      });\r\n\r\n      return data;\r\n\r\n    } catch (error) {\r\n      console.error('Chat service session message error:', error);\r\n      return {\r\n        success: false,\r\n        message: 'Failed to send session message',\r\n        error: error instanceof Error ? error.message : 'Unknown error'\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Primary send message method - tries session first, falls back to direct\r\n   */\r\n  async sendMessage(\r\n    message: string, \r\n    userProfile?: Record<string, any>,\r\n    useCustomModel: boolean = false\r\n  ): Promise<ChatResponse | ChatMessageResponse | null> {\r\n    // Try session-based chat first if session exists\r\n    if (this.currentSessionId) {\r\n      const sessionResponse = await this.sendSessionMessage(message, 'health_chat', useCustomModel);\r\n      if (sessionResponse?.success) {\r\n        return sessionResponse;\r\n      }\r\n    }\r\n\r\n    // Fall back to direct chat (no session required)\r\n    return await this.sendDirectMessage(message, userProfile);\r\n  }\r\n\r\n  /**\r\n   * Set an existing session ID (optional)\r\n   */\r\n  setSessionId(sessionId: string): void {\r\n    this.currentSessionId = sessionId;\r\n    console.log('üîç CHAT SERVICE: Session ID set:', sessionId);\r\n  }\r\n\r\n  /**\r\n   * Clear current session - will use direct chat\r\n   */\r\n  clearSession(): void {\r\n    this.currentSessionId = null;\r\n    this.conversationId = null;\r\n    console.log('üîç CHAT SERVICE: Session cleared, using direct chat');\r\n  }\r\n\r\n  /**\r\n   * Get current session ID (may be null)\r\n   */\r\n  getCurrentSessionId(): string | null {\r\n    return this.currentSessionId;\r\n  }\r\n\r\n  /**\r\n   * Get current conversation ID for direct chat continuity\r\n   */\r\n  getConversationId(): string | null {\r\n    return this.conversationId;\r\n  }\r\n\r\n  /**\r\n   * Set user profile for personalized responses in direct chat\r\n   */\r\n  setUserProfile(profile: Record<string, any>): void {\r\n    this.userProfile = profile;\r\n  }\r\n\r\n  private userProfile?: Record<string, any>;\r\n\r\n  /**\r\n   * Send message with current user profile\r\n   */\r\n  async sendMessageWithProfile(message: string): Promise<ChatResponse | ChatMessageResponse | null> {\r\n    return await this.sendMessage(message, this.userProfile);\r\n  }\r\n}\r\n\r\n// Create and export singleton instance\r\nexport const chatService = new ChatService();\r\n\r\n// Export for type usage\r\nexport default chatService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}